// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2P_Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_P2P_5fProtocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_P2P_5fProtocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_P2P_5fProtocol_2eproto;
namespace p2pfilesharing {
class AddFileRequest;
struct AddFileRequestDefaultTypeInternal;
extern AddFileRequestDefaultTypeInternal _AddFileRequest_default_instance_;
class DeleteFileRequest;
struct DeleteFileRequestDefaultTypeInternal;
extern DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
class LookupFileRequest;
struct LookupFileRequestDefaultTypeInternal;
extern LookupFileRequestDefaultTypeInternal _LookupFileRequest_default_instance_;
class LookupFileResponse;
struct LookupFileResponseDefaultTypeInternal;
extern LookupFileResponseDefaultTypeInternal _LookupFileResponse_default_instance_;
class downloadRequest;
struct downloadRequestDefaultTypeInternal;
extern downloadRequestDefaultTypeInternal _downloadRequest_default_instance_;
class fileInfoRequest;
struct fileInfoRequestDefaultTypeInternal;
extern fileInfoRequestDefaultTypeInternal _fileInfoRequest_default_instance_;
class fileInfoResponse;
struct fileInfoResponseDefaultTypeInternal;
extern fileInfoResponseDefaultTypeInternal _fileInfoResponse_default_instance_;
class fileTable;
struct fileTableDefaultTypeInternal;
extern fileTableDefaultTypeInternal _fileTable_default_instance_;
class fileTableEntry;
struct fileTableEntryDefaultTypeInternal;
extern fileTableEntryDefaultTypeInternal _fileTableEntry_default_instance_;
class joinRequest;
struct joinRequestDefaultTypeInternal;
extern joinRequestDefaultTypeInternal _joinRequest_default_instance_;
class routeDeleteRequest;
struct routeDeleteRequestDefaultTypeInternal;
extern routeDeleteRequestDefaultTypeInternal _routeDeleteRequest_default_instance_;
class routeInsertRequest;
struct routeInsertRequestDefaultTypeInternal;
extern routeInsertRequestDefaultTypeInternal _routeInsertRequest_default_instance_;
class routeTableEntry;
struct routeTableEntryDefaultTypeInternal;
extern routeTableEntryDefaultTypeInternal _routeTableEntry_default_instance_;
class routeTableInit;
struct routeTableInitDefaultTypeInternal;
extern routeTableInitDefaultTypeInternal _routeTableInit_default_instance_;
}  // namespace p2pfilesharing
PROTOBUF_NAMESPACE_OPEN
template<> ::p2pfilesharing::AddFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::AddFileRequest>(Arena*);
template<> ::p2pfilesharing::DeleteFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::DeleteFileRequest>(Arena*);
template<> ::p2pfilesharing::LookupFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::LookupFileRequest>(Arena*);
template<> ::p2pfilesharing::LookupFileResponse* Arena::CreateMaybeMessage<::p2pfilesharing::LookupFileResponse>(Arena*);
template<> ::p2pfilesharing::downloadRequest* Arena::CreateMaybeMessage<::p2pfilesharing::downloadRequest>(Arena*);
template<> ::p2pfilesharing::fileInfoRequest* Arena::CreateMaybeMessage<::p2pfilesharing::fileInfoRequest>(Arena*);
template<> ::p2pfilesharing::fileInfoResponse* Arena::CreateMaybeMessage<::p2pfilesharing::fileInfoResponse>(Arena*);
template<> ::p2pfilesharing::fileTable* Arena::CreateMaybeMessage<::p2pfilesharing::fileTable>(Arena*);
template<> ::p2pfilesharing::fileTableEntry* Arena::CreateMaybeMessage<::p2pfilesharing::fileTableEntry>(Arena*);
template<> ::p2pfilesharing::joinRequest* Arena::CreateMaybeMessage<::p2pfilesharing::joinRequest>(Arena*);
template<> ::p2pfilesharing::routeDeleteRequest* Arena::CreateMaybeMessage<::p2pfilesharing::routeDeleteRequest>(Arena*);
template<> ::p2pfilesharing::routeInsertRequest* Arena::CreateMaybeMessage<::p2pfilesharing::routeInsertRequest>(Arena*);
template<> ::p2pfilesharing::routeTableEntry* Arena::CreateMaybeMessage<::p2pfilesharing::routeTableEntry>(Arena*);
template<> ::p2pfilesharing::routeTableInit* Arena::CreateMaybeMessage<::p2pfilesharing::routeTableInit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace p2pfilesharing {

// ===================================================================

class AddFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.AddFileRequest) */ {
 public:
  inline AddFileRequest() : AddFileRequest(nullptr) {}
  ~AddFileRequest() override;
  explicit PROTOBUF_CONSTEXPR AddFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFileRequest(const AddFileRequest& from);
  AddFileRequest(AddFileRequest&& from) noexcept
    : AddFileRequest() {
    *this = ::std::move(from);
  }

  inline AddFileRequest& operator=(const AddFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFileRequest& operator=(AddFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFileRequest* internal_default_instance() {
    return reinterpret_cast<const AddFileRequest*>(
               &_AddFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AddFileRequest& a, AddFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddFileRequest& from) {
    AddFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.AddFileRequest";
  }
  protected:
  explicit AddFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.AddFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class LookupFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.LookupFileRequest) */ {
 public:
  inline LookupFileRequest() : LookupFileRequest(nullptr) {}
  ~LookupFileRequest() override;
  explicit PROTOBUF_CONSTEXPR LookupFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupFileRequest(const LookupFileRequest& from);
  LookupFileRequest(LookupFileRequest&& from) noexcept
    : LookupFileRequest() {
    *this = ::std::move(from);
  }

  inline LookupFileRequest& operator=(const LookupFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupFileRequest& operator=(LookupFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupFileRequest* internal_default_instance() {
    return reinterpret_cast<const LookupFileRequest*>(
               &_LookupFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LookupFileRequest& a, LookupFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupFileRequest& from) {
    LookupFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.LookupFileRequest";
  }
  protected:
  explicit LookupFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.LookupFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.DeleteFileRequest) */ {
 public:
  inline DeleteFileRequest() : DeleteFileRequest(nullptr) {}
  ~DeleteFileRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileRequest(const DeleteFileRequest& from);
  DeleteFileRequest(DeleteFileRequest&& from) noexcept
    : DeleteFileRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileRequest& operator=(const DeleteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileRequest& operator=(DeleteFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileRequest*>(
               &_DeleteFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteFileRequest& a, DeleteFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFileRequest& from) {
    DeleteFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.DeleteFileRequest";
  }
  protected:
  explicit DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.DeleteFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class LookupFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.LookupFileResponse) */ {
 public:
  inline LookupFileResponse() : LookupFileResponse(nullptr) {}
  ~LookupFileResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupFileResponse(const LookupFileResponse& from);
  LookupFileResponse(LookupFileResponse&& from) noexcept
    : LookupFileResponse() {
    *this = ::std::move(from);
  }

  inline LookupFileResponse& operator=(const LookupFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupFileResponse& operator=(LookupFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupFileResponse* internal_default_instance() {
    return reinterpret_cast<const LookupFileResponse*>(
               &_LookupFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LookupFileResponse& a, LookupFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LookupFileResponse& from) {
    LookupFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.LookupFileResponse";
  }
  protected:
  explicit LookupFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerhostnameFieldNumber = 2,
    kOwnerportFieldNumber = 3,
    kIfexistsFieldNumber = 1,
  };
  // optional string ownerhostname = 2;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // optional string ownerport = 3;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // required bool ifexists = 1;
  bool has_ifexists() const;
  private:
  bool _internal_has_ifexists() const;
  public:
  void clear_ifexists();
  bool ifexists() const;
  void set_ifexists(bool value);
  private:
  bool _internal_ifexists() const;
  void _internal_set_ifexists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.LookupFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
    bool ifexists_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class fileInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.fileInfoRequest) */ {
 public:
  inline fileInfoRequest() : fileInfoRequest(nullptr) {}
  ~fileInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR fileInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  fileInfoRequest(const fileInfoRequest& from);
  fileInfoRequest(fileInfoRequest&& from) noexcept
    : fileInfoRequest() {
    *this = ::std::move(from);
  }

  inline fileInfoRequest& operator=(const fileInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline fileInfoRequest& operator=(fileInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const fileInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const fileInfoRequest* internal_default_instance() {
    return reinterpret_cast<const fileInfoRequest*>(
               &_fileInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(fileInfoRequest& a, fileInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(fileInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(fileInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  fileInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<fileInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const fileInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const fileInfoRequest& from) {
    fileInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fileInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.fileInfoRequest";
  }
  protected:
  explicit fileInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.fileInfoRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class fileInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.fileInfoResponse) */ {
 public:
  inline fileInfoResponse() : fileInfoResponse(nullptr) {}
  ~fileInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR fileInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  fileInfoResponse(const fileInfoResponse& from);
  fileInfoResponse(fileInfoResponse&& from) noexcept
    : fileInfoResponse() {
    *this = ::std::move(from);
  }

  inline fileInfoResponse& operator=(const fileInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline fileInfoResponse& operator=(fileInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const fileInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const fileInfoResponse* internal_default_instance() {
    return reinterpret_cast<const fileInfoResponse*>(
               &_fileInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(fileInfoResponse& a, fileInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(fileInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(fileInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  fileInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<fileInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const fileInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const fileInfoResponse& from) {
    fileInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fileInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.fileInfoResponse";
  }
  protected:
  explicit fileInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerhostnameFieldNumber = 1,
    kOwnerportFieldNumber = 2,
  };
  // required string ownerhostname = 1;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // required string ownerport = 2;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.fileInfoResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class downloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.downloadRequest) */ {
 public:
  inline downloadRequest() : downloadRequest(nullptr) {}
  ~downloadRequest() override;
  explicit PROTOBUF_CONSTEXPR downloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  downloadRequest(const downloadRequest& from);
  downloadRequest(downloadRequest&& from) noexcept
    : downloadRequest() {
    *this = ::std::move(from);
  }

  inline downloadRequest& operator=(const downloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline downloadRequest& operator=(downloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const downloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const downloadRequest* internal_default_instance() {
    return reinterpret_cast<const downloadRequest*>(
               &_downloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(downloadRequest& a, downloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(downloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(downloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  downloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<downloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const downloadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const downloadRequest& from) {
    downloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(downloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.downloadRequest";
  }
  protected:
  explicit downloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.downloadRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class joinRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.joinRequest) */ {
 public:
  inline joinRequest() : joinRequest(nullptr) {}
  ~joinRequest() override;
  explicit PROTOBUF_CONSTEXPR joinRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  joinRequest(const joinRequest& from);
  joinRequest(joinRequest&& from) noexcept
    : joinRequest() {
    *this = ::std::move(from);
  }

  inline joinRequest& operator=(const joinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline joinRequest& operator=(joinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const joinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const joinRequest* internal_default_instance() {
    return reinterpret_cast<const joinRequest*>(
               &_joinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(joinRequest& a, joinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(joinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(joinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  joinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<joinRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const joinRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const joinRequest& from) {
    joinRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(joinRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.joinRequest";
  }
  protected:
  explicit joinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 1,
    kSourceportFieldNumber = 2,
    kHostnamehashFieldNumber = 3,
  };
  // required string sourcehostname = 1;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 2;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 hostnamehash = 3;
  bool has_hostnamehash() const;
  private:
  bool _internal_has_hostnamehash() const;
  public:
  void clear_hostnamehash();
  int64_t hostnamehash() const;
  void set_hostnamehash(int64_t value);
  private:
  int64_t _internal_hostnamehash() const;
  void _internal_set_hostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.joinRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
    int64_t hostnamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class routeTableInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.routeTableInit) */ {
 public:
  inline routeTableInit() : routeTableInit(nullptr) {}
  ~routeTableInit() override;
  explicit PROTOBUF_CONSTEXPR routeTableInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  routeTableInit(const routeTableInit& from);
  routeTableInit(routeTableInit&& from) noexcept
    : routeTableInit() {
    *this = ::std::move(from);
  }

  inline routeTableInit& operator=(const routeTableInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline routeTableInit& operator=(routeTableInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const routeTableInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const routeTableInit* internal_default_instance() {
    return reinterpret_cast<const routeTableInit*>(
               &_routeTableInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(routeTableInit& a, routeTableInit& b) {
    a.Swap(&b);
  }
  inline void Swap(routeTableInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(routeTableInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  routeTableInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<routeTableInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const routeTableInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const routeTableInit& from) {
    routeTableInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(routeTableInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.routeTableInit";
  }
  protected:
  explicit routeTableInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::routeTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::routeTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::routeTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::routeTableEntry& entry(int index) const;
  ::p2pfilesharing::routeTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.routeTableInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class routeTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.routeTableEntry) */ {
 public:
  inline routeTableEntry() : routeTableEntry(nullptr) {}
  ~routeTableEntry() override;
  explicit PROTOBUF_CONSTEXPR routeTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  routeTableEntry(const routeTableEntry& from);
  routeTableEntry(routeTableEntry&& from) noexcept
    : routeTableEntry() {
    *this = ::std::move(from);
  }

  inline routeTableEntry& operator=(const routeTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline routeTableEntry& operator=(routeTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const routeTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const routeTableEntry* internal_default_instance() {
    return reinterpret_cast<const routeTableEntry*>(
               &_routeTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(routeTableEntry& a, routeTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(routeTableEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(routeTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  routeTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<routeTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const routeTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const routeTableEntry& from) {
    routeTableEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(routeTableEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.routeTableEntry";
  }
  protected:
  explicit routeTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kPortFieldNumber = 2,
    kHostnamehashFieldNumber = 3,
  };
  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // required string port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // required int64 hostnamehash = 3;
  bool has_hostnamehash() const;
  private:
  bool _internal_has_hostnamehash() const;
  public:
  void clear_hostnamehash();
  int64_t hostnamehash() const;
  void set_hostnamehash(int64_t value);
  private:
  int64_t _internal_hostnamehash() const;
  void _internal_set_hostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.routeTableEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    int64_t hostnamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class fileTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.fileTable) */ {
 public:
  inline fileTable() : fileTable(nullptr) {}
  ~fileTable() override;
  explicit PROTOBUF_CONSTEXPR fileTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  fileTable(const fileTable& from);
  fileTable(fileTable&& from) noexcept
    : fileTable() {
    *this = ::std::move(from);
  }

  inline fileTable& operator=(const fileTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline fileTable& operator=(fileTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const fileTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const fileTable* internal_default_instance() {
    return reinterpret_cast<const fileTable*>(
               &_fileTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(fileTable& a, fileTable& b) {
    a.Swap(&b);
  }
  inline void Swap(fileTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(fileTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  fileTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<fileTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const fileTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const fileTable& from) {
    fileTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fileTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.fileTable";
  }
  protected:
  explicit fileTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.fileTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::fileTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::fileTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::fileTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::fileTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::fileTableEntry& entry(int index) const;
  ::p2pfilesharing::fileTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::fileTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.fileTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::fileTableEntry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class fileTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.fileTableEntry) */ {
 public:
  inline fileTableEntry() : fileTableEntry(nullptr) {}
  ~fileTableEntry() override;
  explicit PROTOBUF_CONSTEXPR fileTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  fileTableEntry(const fileTableEntry& from);
  fileTableEntry(fileTableEntry&& from) noexcept
    : fileTableEntry() {
    *this = ::std::move(from);
  }

  inline fileTableEntry& operator=(const fileTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline fileTableEntry& operator=(fileTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const fileTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const fileTableEntry* internal_default_instance() {
    return reinterpret_cast<const fileTableEntry*>(
               &_fileTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(fileTableEntry& a, fileTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(fileTableEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(fileTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  fileTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<fileTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const fileTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const fileTableEntry& from) {
    fileTableEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fileTableEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.fileTableEntry";
  }
  protected:
  explicit fileTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerhostnameFieldNumber = 2,
    kOwnerportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string ownerhostname = 2;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // required string ownerport = 3;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.fileTableEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
    int64_t filenamehash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class routeInsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.routeInsertRequest) */ {
 public:
  inline routeInsertRequest() : routeInsertRequest(nullptr) {}
  ~routeInsertRequest() override;
  explicit PROTOBUF_CONSTEXPR routeInsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  routeInsertRequest(const routeInsertRequest& from);
  routeInsertRequest(routeInsertRequest&& from) noexcept
    : routeInsertRequest() {
    *this = ::std::move(from);
  }

  inline routeInsertRequest& operator=(const routeInsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline routeInsertRequest& operator=(routeInsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const routeInsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const routeInsertRequest* internal_default_instance() {
    return reinterpret_cast<const routeInsertRequest*>(
               &_routeInsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(routeInsertRequest& a, routeInsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(routeInsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(routeInsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  routeInsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<routeInsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const routeInsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const routeInsertRequest& from) {
    routeInsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(routeInsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.routeInsertRequest";
  }
  protected:
  explicit routeInsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::routeTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::routeTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::routeTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::routeTableEntry& entry(int index) const;
  ::p2pfilesharing::routeTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.routeInsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class routeDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.routeDeleteRequest) */ {
 public:
  inline routeDeleteRequest() : routeDeleteRequest(nullptr) {}
  ~routeDeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR routeDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  routeDeleteRequest(const routeDeleteRequest& from);
  routeDeleteRequest(routeDeleteRequest&& from) noexcept
    : routeDeleteRequest() {
    *this = ::std::move(from);
  }

  inline routeDeleteRequest& operator=(const routeDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline routeDeleteRequest& operator=(routeDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const routeDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const routeDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const routeDeleteRequest*>(
               &_routeDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(routeDeleteRequest& a, routeDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(routeDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(routeDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  routeDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<routeDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const routeDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const routeDeleteRequest& from) {
    routeDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(routeDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.routeDeleteRequest";
  }
  protected:
  explicit routeDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::routeTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::routeTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::routeTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::routeTableEntry& entry(int index) const;
  ::p2pfilesharing::routeTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.routeDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry > entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddFileRequest

// required int64 filenamehash = 1;
inline bool AddFileRequest::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AddFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void AddFileRequest::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t AddFileRequest::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t AddFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.AddFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void AddFileRequest::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filenamehash_ = value;
}
inline void AddFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.AddFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool AddFileRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void AddFileRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.AddFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.AddFileRequest.sourcehostname)
}
inline std::string* AddFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.AddFileRequest.sourcehostname)
  return _s;
}
inline const std::string& AddFileRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void AddFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFileRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.AddFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AddFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.AddFileRequest.sourcehostname)
}

// -------------------------------------------------------------------

// LookupFileRequest

// required int64 filenamehash = 1;
inline bool LookupFileRequest::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LookupFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void LookupFileRequest::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t LookupFileRequest::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t LookupFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void LookupFileRequest::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filenamehash_ = value;
}
inline void LookupFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool LookupFileRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LookupFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void LookupFileRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.sourcehostname)
}
inline std::string* LookupFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileRequest.sourcehostname)
  return _s;
}
inline const std::string& LookupFileRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void LookupFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool LookupFileRequest::_internal_has_sourceport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LookupFileRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void LookupFileRequest::clear_sourceport() {
  _impl_.sourceport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LookupFileRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.sourceport)
}
inline std::string* LookupFileRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileRequest.sourceport)
  return _s;
}
inline const std::string& LookupFileRequest::_internal_sourceport() const {
  return _impl_.sourceport_.Get();
}
inline void LookupFileRequest::_internal_set_sourceport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileRequest::_internal_mutable_sourceport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileRequest.sourceport)
}

// -------------------------------------------------------------------

// DeleteFileRequest

// required int64 filenamehash = 1;
inline bool DeleteFileRequest::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void DeleteFileRequest::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t DeleteFileRequest::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t DeleteFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void DeleteFileRequest::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filenamehash_ = value;
}
inline void DeleteFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool DeleteFileRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void DeleteFileRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.sourcehostname)
}
inline std::string* DeleteFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DeleteFileRequest.sourcehostname)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void DeleteFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DeleteFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DeleteFileRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool DeleteFileRequest::_internal_has_sourceport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void DeleteFileRequest::clear_sourceport() {
  _impl_.sourceport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeleteFileRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.sourceport)
}
inline std::string* DeleteFileRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DeleteFileRequest.sourceport)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_sourceport() const {
  return _impl_.sourceport_.Get();
}
inline void DeleteFileRequest::_internal_set_sourceport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_sourceport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DeleteFileRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteFileRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DeleteFileRequest.sourceport)
}

// -------------------------------------------------------------------

// LookupFileResponse

// required bool ifexists = 1;
inline bool LookupFileResponse::_internal_has_ifexists() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ifexists() const {
  return _internal_has_ifexists();
}
inline void LookupFileResponse::clear_ifexists() {
  _impl_.ifexists_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool LookupFileResponse::_internal_ifexists() const {
  return _impl_.ifexists_;
}
inline bool LookupFileResponse::ifexists() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ifexists)
  return _internal_ifexists();
}
inline void LookupFileResponse::_internal_set_ifexists(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ifexists_ = value;
}
inline void LookupFileResponse::set_ifexists(bool value) {
  _internal_set_ifexists(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ifexists)
}

// optional string ownerhostname = 2;
inline bool LookupFileResponse::_internal_has_ownerhostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void LookupFileResponse::clear_ownerhostname() {
  _impl_.ownerhostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupFileResponse::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ownerhostname)
}
inline std::string* LookupFileResponse::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.ownerhostname)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_ownerhostname() const {
  return _impl_.ownerhostname_.Get();
}
inline void LookupFileResponse::_internal_set_ownerhostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_ownerhostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.ownerhostname)
}

// optional string ownerport = 3;
inline bool LookupFileResponse::_internal_has_ownerport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void LookupFileResponse::clear_ownerport() {
  _impl_.ownerport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LookupFileResponse::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ownerport)
}
inline std::string* LookupFileResponse::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.ownerport)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_ownerport() const {
  return _impl_.ownerport_.Get();
}
inline void LookupFileResponse::_internal_set_ownerport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_ownerport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.ownerport)
}

// -------------------------------------------------------------------

// fileInfoRequest

// required int64 filenamehash = 1;
inline bool fileInfoRequest::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool fileInfoRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void fileInfoRequest::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t fileInfoRequest::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t fileInfoRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileInfoRequest.filenamehash)
  return _internal_filenamehash();
}
inline void fileInfoRequest::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filenamehash_ = value;
}
inline void fileInfoRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileInfoRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool fileInfoRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool fileInfoRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void fileInfoRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& fileInfoRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileInfoRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileInfoRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileInfoRequest.sourcehostname)
}
inline std::string* fileInfoRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileInfoRequest.sourcehostname)
  return _s;
}
inline const std::string& fileInfoRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void fileInfoRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* fileInfoRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* fileInfoRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileInfoRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileInfoRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileInfoRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool fileInfoRequest::_internal_has_sourceport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool fileInfoRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void fileInfoRequest::clear_sourceport() {
  _impl_.sourceport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& fileInfoRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileInfoRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileInfoRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileInfoRequest.sourceport)
}
inline std::string* fileInfoRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileInfoRequest.sourceport)
  return _s;
}
inline const std::string& fileInfoRequest::_internal_sourceport() const {
  return _impl_.sourceport_.Get();
}
inline void fileInfoRequest::_internal_set_sourceport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* fileInfoRequest::_internal_mutable_sourceport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* fileInfoRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileInfoRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileInfoRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileInfoRequest.sourceport)
}

// -------------------------------------------------------------------

// fileInfoResponse

// required string ownerhostname = 1;
inline bool fileInfoResponse::_internal_has_ownerhostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool fileInfoResponse::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void fileInfoResponse::clear_ownerhostname() {
  _impl_.ownerhostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& fileInfoResponse::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileInfoResponse.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileInfoResponse::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileInfoResponse.ownerhostname)
}
inline std::string* fileInfoResponse::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileInfoResponse.ownerhostname)
  return _s;
}
inline const std::string& fileInfoResponse::_internal_ownerhostname() const {
  return _impl_.ownerhostname_.Get();
}
inline void fileInfoResponse::_internal_set_ownerhostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* fileInfoResponse::_internal_mutable_ownerhostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* fileInfoResponse::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileInfoResponse.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileInfoResponse::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileInfoResponse.ownerhostname)
}

// required string ownerport = 2;
inline bool fileInfoResponse::_internal_has_ownerport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool fileInfoResponse::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void fileInfoResponse::clear_ownerport() {
  _impl_.ownerport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& fileInfoResponse::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileInfoResponse.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileInfoResponse::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileInfoResponse.ownerport)
}
inline std::string* fileInfoResponse::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileInfoResponse.ownerport)
  return _s;
}
inline const std::string& fileInfoResponse::_internal_ownerport() const {
  return _impl_.ownerport_.Get();
}
inline void fileInfoResponse::_internal_set_ownerport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* fileInfoResponse::_internal_mutable_ownerport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* fileInfoResponse::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileInfoResponse.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileInfoResponse::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileInfoResponse.ownerport)
}

// -------------------------------------------------------------------

// downloadRequest

// required int64 filenamehash = 1;
inline bool downloadRequest::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool downloadRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void downloadRequest::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t downloadRequest::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t downloadRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.downloadRequest.filenamehash)
  return _internal_filenamehash();
}
inline void downloadRequest::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filenamehash_ = value;
}
inline void downloadRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.downloadRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool downloadRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool downloadRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void downloadRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& downloadRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.downloadRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void downloadRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.downloadRequest.sourcehostname)
}
inline std::string* downloadRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.downloadRequest.sourcehostname)
  return _s;
}
inline const std::string& downloadRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void downloadRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* downloadRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* downloadRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.downloadRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void downloadRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.downloadRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool downloadRequest::_internal_has_sourceport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool downloadRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void downloadRequest::clear_sourceport() {
  _impl_.sourceport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& downloadRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.downloadRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void downloadRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.downloadRequest.sourceport)
}
inline std::string* downloadRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.downloadRequest.sourceport)
  return _s;
}
inline const std::string& downloadRequest::_internal_sourceport() const {
  return _impl_.sourceport_.Get();
}
inline void downloadRequest::_internal_set_sourceport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* downloadRequest::_internal_mutable_sourceport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* downloadRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.downloadRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void downloadRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.downloadRequest.sourceport)
}

// -------------------------------------------------------------------

// joinRequest

// required string sourcehostname = 1;
inline bool joinRequest::_internal_has_sourcehostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool joinRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void joinRequest::clear_sourcehostname() {
  _impl_.sourcehostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& joinRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.joinRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void joinRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.joinRequest.sourcehostname)
}
inline std::string* joinRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.joinRequest.sourcehostname)
  return _s;
}
inline const std::string& joinRequest::_internal_sourcehostname() const {
  return _impl_.sourcehostname_.Get();
}
inline void joinRequest::_internal_set_sourcehostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* joinRequest::_internal_mutable_sourcehostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* joinRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.joinRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void joinRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcehostname_.IsDefault()) {
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.joinRequest.sourcehostname)
}

// required string sourceport = 2;
inline bool joinRequest::_internal_has_sourceport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool joinRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void joinRequest::clear_sourceport() {
  _impl_.sourceport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& joinRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.joinRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void joinRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.joinRequest.sourceport)
}
inline std::string* joinRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.joinRequest.sourceport)
  return _s;
}
inline const std::string& joinRequest::_internal_sourceport() const {
  return _impl_.sourceport_.Get();
}
inline void joinRequest::_internal_set_sourceport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* joinRequest::_internal_mutable_sourceport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* joinRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.joinRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void joinRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceport_.IsDefault()) {
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.joinRequest.sourceport)
}

// required int64 hostnamehash = 3;
inline bool joinRequest::_internal_has_hostnamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool joinRequest::has_hostnamehash() const {
  return _internal_has_hostnamehash();
}
inline void joinRequest::clear_hostnamehash() {
  _impl_.hostnamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t joinRequest::_internal_hostnamehash() const {
  return _impl_.hostnamehash_;
}
inline int64_t joinRequest::hostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.joinRequest.hostnamehash)
  return _internal_hostnamehash();
}
inline void joinRequest::_internal_set_hostnamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hostnamehash_ = value;
}
inline void joinRequest::set_hostnamehash(int64_t value) {
  _internal_set_hostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.joinRequest.hostnamehash)
}

// -------------------------------------------------------------------

// routeTableInit

// repeated .p2pfilesharing.routeTableEntry entry = 1;
inline int routeTableInit::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int routeTableInit::entry_size() const {
  return _internal_entry_size();
}
inline void routeTableInit::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::p2pfilesharing::routeTableEntry* routeTableInit::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.routeTableInit.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
routeTableInit::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.routeTableInit.entry)
  return &_impl_.entry_;
}
inline const ::p2pfilesharing::routeTableEntry& routeTableInit::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::p2pfilesharing::routeTableEntry& routeTableInit::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeTableInit.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::routeTableEntry* routeTableInit::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::p2pfilesharing::routeTableEntry* routeTableInit::add_entry() {
  ::p2pfilesharing::routeTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.routeTableInit.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
routeTableInit::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.routeTableInit.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// routeTableEntry

// required string hostname = 1;
inline bool routeTableEntry::_internal_has_hostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool routeTableEntry::has_hostname() const {
  return _internal_has_hostname();
}
inline void routeTableEntry::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& routeTableEntry::hostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeTableEntry.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void routeTableEntry::set_hostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.routeTableEntry.hostname)
}
inline std::string* routeTableEntry::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.routeTableEntry.hostname)
  return _s;
}
inline const std::string& routeTableEntry::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void routeTableEntry::_internal_set_hostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* routeTableEntry::_internal_mutable_hostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* routeTableEntry::release_hostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.routeTableEntry.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void routeTableEntry::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.routeTableEntry.hostname)
}

// required string port = 2;
inline bool routeTableEntry::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool routeTableEntry::has_port() const {
  return _internal_has_port();
}
inline void routeTableEntry::clear_port() {
  _impl_.port_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& routeTableEntry::port() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeTableEntry.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void routeTableEntry::set_port(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.routeTableEntry.port)
}
inline std::string* routeTableEntry::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.routeTableEntry.port)
  return _s;
}
inline const std::string& routeTableEntry::_internal_port() const {
  return _impl_.port_.Get();
}
inline void routeTableEntry::_internal_set_port(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* routeTableEntry::_internal_mutable_port() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.port_.Mutable(GetArenaForAllocation());
}
inline std::string* routeTableEntry::release_port() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.routeTableEntry.port)
  if (!_internal_has_port()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void routeTableEntry::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.port_.IsDefault()) {
    _impl_.port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.routeTableEntry.port)
}

// required int64 hostnamehash = 3;
inline bool routeTableEntry::_internal_has_hostnamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool routeTableEntry::has_hostnamehash() const {
  return _internal_has_hostnamehash();
}
inline void routeTableEntry::clear_hostnamehash() {
  _impl_.hostnamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t routeTableEntry::_internal_hostnamehash() const {
  return _impl_.hostnamehash_;
}
inline int64_t routeTableEntry::hostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeTableEntry.hostnamehash)
  return _internal_hostnamehash();
}
inline void routeTableEntry::_internal_set_hostnamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hostnamehash_ = value;
}
inline void routeTableEntry::set_hostnamehash(int64_t value) {
  _internal_set_hostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.routeTableEntry.hostnamehash)
}

// -------------------------------------------------------------------

// fileTable

// repeated .p2pfilesharing.fileTableEntry entry = 1;
inline int fileTable::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int fileTable::entry_size() const {
  return _internal_entry_size();
}
inline void fileTable::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::p2pfilesharing::fileTableEntry* fileTable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileTable.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::fileTableEntry >*
fileTable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.fileTable.entry)
  return &_impl_.entry_;
}
inline const ::p2pfilesharing::fileTableEntry& fileTable::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::p2pfilesharing::fileTableEntry& fileTable::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileTable.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::fileTableEntry* fileTable::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::p2pfilesharing::fileTableEntry* fileTable::add_entry() {
  ::p2pfilesharing::fileTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.fileTable.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::fileTableEntry >&
fileTable::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.fileTable.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// fileTableEntry

// required int64 filenamehash = 1;
inline bool fileTableEntry::_internal_has_filenamehash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool fileTableEntry::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void fileTableEntry::clear_filenamehash() {
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t fileTableEntry::_internal_filenamehash() const {
  return _impl_.filenamehash_;
}
inline int64_t fileTableEntry::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileTableEntry.filenamehash)
  return _internal_filenamehash();
}
inline void fileTableEntry::_internal_set_filenamehash(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filenamehash_ = value;
}
inline void fileTableEntry::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileTableEntry.filenamehash)
}

// required string ownerhostname = 2;
inline bool fileTableEntry::_internal_has_ownerhostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool fileTableEntry::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void fileTableEntry::clear_ownerhostname() {
  _impl_.ownerhostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& fileTableEntry::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileTableEntry.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileTableEntry::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileTableEntry.ownerhostname)
}
inline std::string* fileTableEntry::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileTableEntry.ownerhostname)
  return _s;
}
inline const std::string& fileTableEntry::_internal_ownerhostname() const {
  return _impl_.ownerhostname_.Get();
}
inline void fileTableEntry::_internal_set_ownerhostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* fileTableEntry::_internal_mutable_ownerhostname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* fileTableEntry::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileTableEntry.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileTableEntry::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerhostname_.IsDefault()) {
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileTableEntry.ownerhostname)
}

// required string ownerport = 3;
inline bool fileTableEntry::_internal_has_ownerport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool fileTableEntry::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void fileTableEntry::clear_ownerport() {
  _impl_.ownerport_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& fileTableEntry::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.fileTableEntry.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void fileTableEntry::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.fileTableEntry.ownerport)
}
inline std::string* fileTableEntry::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.fileTableEntry.ownerport)
  return _s;
}
inline const std::string& fileTableEntry::_internal_ownerport() const {
  return _impl_.ownerport_.Get();
}
inline void fileTableEntry::_internal_set_ownerport(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* fileTableEntry::_internal_mutable_ownerport() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* fileTableEntry::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.fileTableEntry.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void fileTableEntry::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ownerport_.IsDefault()) {
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.fileTableEntry.ownerport)
}

// -------------------------------------------------------------------

// routeInsertRequest

// repeated .p2pfilesharing.routeTableEntry entry = 1;
inline int routeInsertRequest::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int routeInsertRequest::entry_size() const {
  return _internal_entry_size();
}
inline void routeInsertRequest::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::p2pfilesharing::routeTableEntry* routeInsertRequest::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.routeInsertRequest.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
routeInsertRequest::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.routeInsertRequest.entry)
  return &_impl_.entry_;
}
inline const ::p2pfilesharing::routeTableEntry& routeInsertRequest::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::p2pfilesharing::routeTableEntry& routeInsertRequest::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeInsertRequest.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::routeTableEntry* routeInsertRequest::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::p2pfilesharing::routeTableEntry* routeInsertRequest::add_entry() {
  ::p2pfilesharing::routeTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.routeInsertRequest.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
routeInsertRequest::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.routeInsertRequest.entry)
  return _impl_.entry_;
}

// -------------------------------------------------------------------

// routeDeleteRequest

// repeated .p2pfilesharing.routeTableEntry entry = 1;
inline int routeDeleteRequest::_internal_entry_size() const {
  return _impl_.entry_.size();
}
inline int routeDeleteRequest::entry_size() const {
  return _internal_entry_size();
}
inline void routeDeleteRequest::clear_entry() {
  _impl_.entry_.Clear();
}
inline ::p2pfilesharing::routeTableEntry* routeDeleteRequest::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.routeDeleteRequest.entry)
  return _impl_.entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >*
routeDeleteRequest::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.routeDeleteRequest.entry)
  return &_impl_.entry_;
}
inline const ::p2pfilesharing::routeTableEntry& routeDeleteRequest::_internal_entry(int index) const {
  return _impl_.entry_.Get(index);
}
inline const ::p2pfilesharing::routeTableEntry& routeDeleteRequest::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.routeDeleteRequest.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::routeTableEntry* routeDeleteRequest::_internal_add_entry() {
  return _impl_.entry_.Add();
}
inline ::p2pfilesharing::routeTableEntry* routeDeleteRequest::add_entry() {
  ::p2pfilesharing::routeTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.routeDeleteRequest.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::routeTableEntry >&
routeDeleteRequest::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.routeDeleteRequest.entry)
  return _impl_.entry_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace p2pfilesharing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto
