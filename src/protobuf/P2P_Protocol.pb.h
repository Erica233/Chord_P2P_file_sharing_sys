// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2P_Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_P2P_5fProtocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_P2P_5fProtocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_P2P_5fProtocol_2eproto;
namespace p2pfilesharing {
class AddFileRequest;
struct AddFileRequestDefaultTypeInternal;
extern AddFileRequestDefaultTypeInternal _AddFileRequest_default_instance_;
class DeleteFileRequest;
struct DeleteFileRequestDefaultTypeInternal;
extern DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class FileInfoResponse;
struct FileInfoResponseDefaultTypeInternal;
extern FileInfoResponseDefaultTypeInternal _FileInfoResponse_default_instance_;
class FileTable;
struct FileTableDefaultTypeInternal;
extern FileTableDefaultTypeInternal _FileTable_default_instance_;
class FileTableEntry;
struct FileTableEntryDefaultTypeInternal;
extern FileTableEntryDefaultTypeInternal _FileTableEntry_default_instance_;
class HelpJoinRequset;
struct HelpJoinRequsetDefaultTypeInternal;
extern HelpJoinRequsetDefaultTypeInternal _HelpJoinRequset_default_instance_;
class HelpJoinResponse;
struct HelpJoinResponseDefaultTypeInternal;
extern HelpJoinResponseDefaultTypeInternal _HelpJoinResponse_default_instance_;
class JoinRequest;
struct JoinRequestDefaultTypeInternal;
extern JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
class LookupFileRequest;
struct LookupFileRequestDefaultTypeInternal;
extern LookupFileRequestDefaultTypeInternal _LookupFileRequest_default_instance_;
class LookupFileResponse;
struct LookupFileResponseDefaultTypeInternal;
extern LookupFileResponseDefaultTypeInternal _LookupFileResponse_default_instance_;
class LookupNodeResponse;
struct LookupNodeResponseDefaultTypeInternal;
extern LookupNodeResponseDefaultTypeInternal _LookupNodeResponse_default_instance_;
class NodeRequest;
struct NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class NodeResponse;
struct NodeResponseDefaultTypeInternal;
extern NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
class RouteDeleteRequest;
struct RouteDeleteRequestDefaultTypeInternal;
extern RouteDeleteRequestDefaultTypeInternal _RouteDeleteRequest_default_instance_;
class RouteTableEntry;
struct RouteTableEntryDefaultTypeInternal;
extern RouteTableEntryDefaultTypeInternal _RouteTableEntry_default_instance_;
class RouteTableInit;
struct RouteTableInitDefaultTypeInternal;
extern RouteTableInitDefaultTypeInternal _RouteTableInit_default_instance_;
class RouteUpdateRequest;
struct RouteUpdateRequestDefaultTypeInternal;
extern RouteUpdateRequestDefaultTypeInternal _RouteUpdateRequest_default_instance_;
class RouteUpdateResponse;
struct RouteUpdateResponseDefaultTypeInternal;
extern RouteUpdateResponseDefaultTypeInternal _RouteUpdateResponse_default_instance_;
}  // namespace p2pfilesharing
PROTOBUF_NAMESPACE_OPEN
template<> ::p2pfilesharing::AddFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::AddFileRequest>(Arena*);
template<> ::p2pfilesharing::DeleteFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::DeleteFileRequest>(Arena*);
template<> ::p2pfilesharing::DownloadRequest* Arena::CreateMaybeMessage<::p2pfilesharing::DownloadRequest>(Arena*);
template<> ::p2pfilesharing::FileInfoResponse* Arena::CreateMaybeMessage<::p2pfilesharing::FileInfoResponse>(Arena*);
template<> ::p2pfilesharing::FileTable* Arena::CreateMaybeMessage<::p2pfilesharing::FileTable>(Arena*);
template<> ::p2pfilesharing::FileTableEntry* Arena::CreateMaybeMessage<::p2pfilesharing::FileTableEntry>(Arena*);
template<> ::p2pfilesharing::HelpJoinRequset* Arena::CreateMaybeMessage<::p2pfilesharing::HelpJoinRequset>(Arena*);
template<> ::p2pfilesharing::HelpJoinResponse* Arena::CreateMaybeMessage<::p2pfilesharing::HelpJoinResponse>(Arena*);
template<> ::p2pfilesharing::JoinRequest* Arena::CreateMaybeMessage<::p2pfilesharing::JoinRequest>(Arena*);
template<> ::p2pfilesharing::LookupFileRequest* Arena::CreateMaybeMessage<::p2pfilesharing::LookupFileRequest>(Arena*);
template<> ::p2pfilesharing::LookupFileResponse* Arena::CreateMaybeMessage<::p2pfilesharing::LookupFileResponse>(Arena*);
template<> ::p2pfilesharing::LookupNodeResponse* Arena::CreateMaybeMessage<::p2pfilesharing::LookupNodeResponse>(Arena*);
template<> ::p2pfilesharing::NodeRequest* Arena::CreateMaybeMessage<::p2pfilesharing::NodeRequest>(Arena*);
template<> ::p2pfilesharing::NodeResponse* Arena::CreateMaybeMessage<::p2pfilesharing::NodeResponse>(Arena*);
template<> ::p2pfilesharing::RouteDeleteRequest* Arena::CreateMaybeMessage<::p2pfilesharing::RouteDeleteRequest>(Arena*);
template<> ::p2pfilesharing::RouteTableEntry* Arena::CreateMaybeMessage<::p2pfilesharing::RouteTableEntry>(Arena*);
template<> ::p2pfilesharing::RouteTableInit* Arena::CreateMaybeMessage<::p2pfilesharing::RouteTableInit>(Arena*);
template<> ::p2pfilesharing::RouteUpdateRequest* Arena::CreateMaybeMessage<::p2pfilesharing::RouteUpdateRequest>(Arena*);
template<> ::p2pfilesharing::RouteUpdateResponse* Arena::CreateMaybeMessage<::p2pfilesharing::RouteUpdateResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace p2pfilesharing {

// ===================================================================

class AddFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.AddFileRequest) */ {
 public:
  inline AddFileRequest() : AddFileRequest(nullptr) {}
  ~AddFileRequest() override;
  explicit PROTOBUF_CONSTEXPR AddFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFileRequest(const AddFileRequest& from);
  AddFileRequest(AddFileRequest&& from) noexcept
    : AddFileRequest() {
    *this = ::std::move(from);
  }

  inline AddFileRequest& operator=(const AddFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFileRequest& operator=(AddFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFileRequest* internal_default_instance() {
    return reinterpret_cast<const AddFileRequest*>(
               &_AddFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AddFileRequest& a, AddFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.AddFileRequest";
  }
  protected:
  explicit AddFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.AddFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
  int64_t filenamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class LookupFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.LookupFileRequest) */ {
 public:
  inline LookupFileRequest() : LookupFileRequest(nullptr) {}
  ~LookupFileRequest() override;
  explicit PROTOBUF_CONSTEXPR LookupFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupFileRequest(const LookupFileRequest& from);
  LookupFileRequest(LookupFileRequest&& from) noexcept
    : LookupFileRequest() {
    *this = ::std::move(from);
  }

  inline LookupFileRequest& operator=(const LookupFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupFileRequest& operator=(LookupFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupFileRequest* internal_default_instance() {
    return reinterpret_cast<const LookupFileRequest*>(
               &_LookupFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LookupFileRequest& a, LookupFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.LookupFileRequest";
  }
  protected:
  explicit LookupFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.LookupFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
  int64_t filenamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.DeleteFileRequest) */ {
 public:
  inline DeleteFileRequest() : DeleteFileRequest(nullptr) {}
  ~DeleteFileRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileRequest(const DeleteFileRequest& from);
  DeleteFileRequest(DeleteFileRequest&& from) noexcept
    : DeleteFileRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileRequest& operator=(const DeleteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileRequest& operator=(DeleteFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileRequest*>(
               &_DeleteFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteFileRequest& a, DeleteFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.DeleteFileRequest";
  }
  protected:
  explicit DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.DeleteFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
  int64_t filenamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class LookupFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.LookupFileResponse) */ {
 public:
  inline LookupFileResponse() : LookupFileResponse(nullptr) {}
  ~LookupFileResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupFileResponse(const LookupFileResponse& from);
  LookupFileResponse(LookupFileResponse&& from) noexcept
    : LookupFileResponse() {
    *this = ::std::move(from);
  }

  inline LookupFileResponse& operator=(const LookupFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupFileResponse& operator=(LookupFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupFileResponse* internal_default_instance() {
    return reinterpret_cast<const LookupFileResponse*>(
               &_LookupFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LookupFileResponse& a, LookupFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.LookupFileResponse";
  }
  protected:
  explicit LookupFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessorhostnameFieldNumber = 2,
    kSuccessorportFieldNumber = 3,
    kOwnerhostnameFieldNumber = 4,
    kOwnerportFieldNumber = 5,
    kIfexistsFieldNumber = 1,
  };
  // required string successorhostname = 2;
  bool has_successorhostname() const;
  private:
  bool _internal_has_successorhostname() const;
  public:
  void clear_successorhostname();
  const std::string& successorhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_successorhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_successorhostname();
  PROTOBUF_NODISCARD std::string* release_successorhostname();
  void set_allocated_successorhostname(std::string* successorhostname);
  private:
  const std::string& _internal_successorhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_successorhostname(const std::string& value);
  std::string* _internal_mutable_successorhostname();
  public:

  // required string successorport = 3;
  bool has_successorport() const;
  private:
  bool _internal_has_successorport() const;
  public:
  void clear_successorport();
  const std::string& successorport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_successorport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_successorport();
  PROTOBUF_NODISCARD std::string* release_successorport();
  void set_allocated_successorport(std::string* successorport);
  private:
  const std::string& _internal_successorport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_successorport(const std::string& value);
  std::string* _internal_mutable_successorport();
  public:

  // optional string ownerhostname = 4;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // optional string ownerport = 5;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // required bool ifexists = 1;
  bool has_ifexists() const;
  private:
  bool _internal_has_ifexists() const;
  public:
  void clear_ifexists();
  bool ifexists() const;
  void set_ifexists(bool value);
  private:
  bool _internal_ifexists() const;
  void _internal_set_ifexists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.LookupFileResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr successorhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr successorport_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
  bool ifexists_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class FileInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.FileInfoResponse) */ {
 public:
  inline FileInfoResponse() : FileInfoResponse(nullptr) {}
  ~FileInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR FileInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfoResponse(const FileInfoResponse& from);
  FileInfoResponse(FileInfoResponse&& from) noexcept
    : FileInfoResponse() {
    *this = ::std::move(from);
  }

  inline FileInfoResponse& operator=(const FileInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfoResponse& operator=(FileInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfoResponse* internal_default_instance() {
    return reinterpret_cast<const FileInfoResponse*>(
               &_FileInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileInfoResponse& a, FileInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.FileInfoResponse";
  }
  protected:
  explicit FileInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerhostnameFieldNumber = 1,
    kOwnerportFieldNumber = 2,
  };
  // required string ownerhostname = 1;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // required string ownerport = 2;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.FileInfoResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class DownloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadRequest(const DownloadRequest& from);
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DownloadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DownloadRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcehostnameFieldNumber = 2,
    kSourceportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string sourcehostname = 2;
  bool has_sourcehostname() const;
  private:
  bool _internal_has_sourcehostname() const;
  public:
  void clear_sourcehostname();
  const std::string& sourcehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcehostname();
  PROTOBUF_NODISCARD std::string* release_sourcehostname();
  void set_allocated_sourcehostname(std::string* sourcehostname);
  private:
  const std::string& _internal_sourcehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcehostname(const std::string& value);
  std::string* _internal_mutable_sourcehostname();
  public:

  // required string sourceport = 3;
  bool has_sourceport() const;
  private:
  bool _internal_has_sourceport() const;
  public:
  void clear_sourceport();
  const std::string& sourceport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceport();
  PROTOBUF_NODISCARD std::string* release_sourceport();
  void set_allocated_sourceport(std::string* sourceport);
  private:
  const std::string& _internal_sourceport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceport(const std::string& value);
  std::string* _internal_mutable_sourceport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.DownloadRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceport_;
  int64_t filenamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.JoinRequest) */ {
 public:
  inline JoinRequest() : JoinRequest(nullptr) {}
  ~JoinRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRequest(const JoinRequest& from);
  JoinRequest(JoinRequest&& from) noexcept
    : JoinRequest() {
    *this = ::std::move(from);
  }

  inline JoinRequest& operator=(const JoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRequest& operator=(JoinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRequest*>(
               &_JoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoinRequest& a, JoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.JoinRequest";
  }
  protected:
  explicit JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewhostnameFieldNumber = 1,
    kNewportFieldNumber = 2,
    kNewhostnamehashFieldNumber = 3,
  };
  // required string newhostname = 1;
  bool has_newhostname() const;
  private:
  bool _internal_has_newhostname() const;
  public:
  void clear_newhostname();
  const std::string& newhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newhostname();
  PROTOBUF_NODISCARD std::string* release_newhostname();
  void set_allocated_newhostname(std::string* newhostname);
  private:
  const std::string& _internal_newhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newhostname(const std::string& value);
  std::string* _internal_mutable_newhostname();
  public:

  // required string newport = 2;
  bool has_newport() const;
  private:
  bool _internal_has_newport() const;
  public:
  void clear_newport();
  const std::string& newport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newport();
  PROTOBUF_NODISCARD std::string* release_newport();
  void set_allocated_newport(std::string* newport);
  private:
  const std::string& _internal_newport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newport(const std::string& value);
  std::string* _internal_mutable_newport();
  public:

  // required int64 newhostnamehash = 3;
  bool has_newhostnamehash() const;
  private:
  bool _internal_has_newhostnamehash() const;
  public:
  void clear_newhostnamehash();
  int64_t newhostnamehash() const;
  void set_newhostnamehash(int64_t value);
  private:
  int64_t _internal_newhostnamehash() const;
  void _internal_set_newhostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.JoinRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newport_;
  int64_t newhostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class RouteTableInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.RouteTableInit) */ {
 public:
  inline RouteTableInit() : RouteTableInit(nullptr) {}
  ~RouteTableInit() override;
  explicit PROTOBUF_CONSTEXPR RouteTableInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTableInit(const RouteTableInit& from);
  RouteTableInit(RouteTableInit&& from) noexcept
    : RouteTableInit() {
    *this = ::std::move(from);
  }

  inline RouteTableInit& operator=(const RouteTableInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTableInit& operator=(RouteTableInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTableInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTableInit* internal_default_instance() {
    return reinterpret_cast<const RouteTableInit*>(
               &_RouteTableInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RouteTableInit& a, RouteTableInit& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTableInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTableInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteTableInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteTableInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTableInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTableInit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTableInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.RouteTableInit";
  }
  protected:
  explicit RouteTableInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::RouteTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::RouteTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::RouteTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::RouteTableEntry& entry(int index) const;
  ::p2pfilesharing::RouteTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.RouteTableInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class RouteTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.RouteTableEntry) */ {
 public:
  inline RouteTableEntry() : RouteTableEntry(nullptr) {}
  ~RouteTableEntry() override;
  explicit PROTOBUF_CONSTEXPR RouteTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTableEntry(const RouteTableEntry& from);
  RouteTableEntry(RouteTableEntry&& from) noexcept
    : RouteTableEntry() {
    *this = ::std::move(from);
  }

  inline RouteTableEntry& operator=(const RouteTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTableEntry& operator=(RouteTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTableEntry* internal_default_instance() {
    return reinterpret_cast<const RouteTableEntry*>(
               &_RouteTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RouteTableEntry& a, RouteTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTableEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTableEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.RouteTableEntry";
  }
  protected:
  explicit RouteTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kPortFieldNumber = 2,
    kHostnamehashFieldNumber = 3,
  };
  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // required string port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // required int64 hostnamehash = 3;
  bool has_hostnamehash() const;
  private:
  bool _internal_has_hostnamehash() const;
  public:
  void clear_hostnamehash();
  int64_t hostnamehash() const;
  void set_hostnamehash(int64_t value);
  private:
  int64_t _internal_hostnamehash() const;
  void _internal_set_hostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.RouteTableEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  int64_t hostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class FileTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.FileTable) */ {
 public:
  inline FileTable() : FileTable(nullptr) {}
  ~FileTable() override;
  explicit PROTOBUF_CONSTEXPR FileTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTable(const FileTable& from);
  FileTable(FileTable&& from) noexcept
    : FileTable() {
    *this = ::std::move(from);
  }

  inline FileTable& operator=(const FileTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTable& operator=(FileTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTable* internal_default_instance() {
    return reinterpret_cast<const FileTable*>(
               &_FileTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FileTable& a, FileTable& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.FileTable";
  }
  protected:
  explicit FileTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.FileTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::FileTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::FileTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::FileTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::FileTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::FileTableEntry& entry(int index) const;
  ::p2pfilesharing::FileTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::FileTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.FileTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::FileTableEntry > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class FileTableEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.FileTableEntry) */ {
 public:
  inline FileTableEntry() : FileTableEntry(nullptr) {}
  ~FileTableEntry() override;
  explicit PROTOBUF_CONSTEXPR FileTableEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTableEntry(const FileTableEntry& from);
  FileTableEntry(FileTableEntry&& from) noexcept
    : FileTableEntry() {
    *this = ::std::move(from);
  }

  inline FileTableEntry& operator=(const FileTableEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTableEntry& operator=(FileTableEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTableEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTableEntry* internal_default_instance() {
    return reinterpret_cast<const FileTableEntry*>(
               &_FileTableEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FileTableEntry& a, FileTableEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTableEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTableEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTableEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTableEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTableEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileTableEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTableEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.FileTableEntry";
  }
  protected:
  explicit FileTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerhostnameFieldNumber = 2,
    kOwnerportFieldNumber = 3,
    kFilenamehashFieldNumber = 1,
  };
  // required string ownerhostname = 2;
  bool has_ownerhostname() const;
  private:
  bool _internal_has_ownerhostname() const;
  public:
  void clear_ownerhostname();
  const std::string& ownerhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerhostname();
  PROTOBUF_NODISCARD std::string* release_ownerhostname();
  void set_allocated_ownerhostname(std::string* ownerhostname);
  private:
  const std::string& _internal_ownerhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerhostname(const std::string& value);
  std::string* _internal_mutable_ownerhostname();
  public:

  // required string ownerport = 3;
  bool has_ownerport() const;
  private:
  bool _internal_has_ownerport() const;
  public:
  void clear_ownerport();
  const std::string& ownerport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ownerport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ownerport();
  PROTOBUF_NODISCARD std::string* release_ownerport();
  void set_allocated_ownerport(std::string* ownerport);
  private:
  const std::string& _internal_ownerport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownerport(const std::string& value);
  std::string* _internal_mutable_ownerport();
  public:

  // required int64 filenamehash = 1;
  bool has_filenamehash() const;
  private:
  bool _internal_has_filenamehash() const;
  public:
  void clear_filenamehash();
  int64_t filenamehash() const;
  void set_filenamehash(int64_t value);
  private:
  int64_t _internal_filenamehash() const;
  void _internal_set_filenamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.FileTableEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ownerport_;
  int64_t filenamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class RouteUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.RouteUpdateRequest) */ {
 public:
  inline RouteUpdateRequest() : RouteUpdateRequest(nullptr) {}
  ~RouteUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR RouteUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteUpdateRequest(const RouteUpdateRequest& from);
  RouteUpdateRequest(RouteUpdateRequest&& from) noexcept
    : RouteUpdateRequest() {
    *this = ::std::move(from);
  }

  inline RouteUpdateRequest& operator=(const RouteUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteUpdateRequest& operator=(RouteUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const RouteUpdateRequest*>(
               &_RouteUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RouteUpdateRequest& a, RouteUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.RouteUpdateRequest";
  }
  protected:
  explicit RouteUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewhostnameFieldNumber = 1,
    kNewportFieldNumber = 2,
    kNewhostnamehashFieldNumber = 3,
  };
  // required string newhostname = 1;
  bool has_newhostname() const;
  private:
  bool _internal_has_newhostname() const;
  public:
  void clear_newhostname();
  const std::string& newhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newhostname();
  PROTOBUF_NODISCARD std::string* release_newhostname();
  void set_allocated_newhostname(std::string* newhostname);
  private:
  const std::string& _internal_newhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newhostname(const std::string& value);
  std::string* _internal_mutable_newhostname();
  public:

  // required string newport = 2;
  bool has_newport() const;
  private:
  bool _internal_has_newport() const;
  public:
  void clear_newport();
  const std::string& newport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newport();
  PROTOBUF_NODISCARD std::string* release_newport();
  void set_allocated_newport(std::string* newport);
  private:
  const std::string& _internal_newport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newport(const std::string& value);
  std::string* _internal_mutable_newport();
  public:

  // required int64 newhostnamehash = 3;
  bool has_newhostnamehash() const;
  private:
  bool _internal_has_newhostnamehash() const;
  public:
  void clear_newhostnamehash();
  int64_t newhostnamehash() const;
  void set_newhostnamehash(int64_t value);
  private:
  int64_t _internal_newhostnamehash() const;
  void _internal_set_newhostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.RouteUpdateRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newport_;
  int64_t newhostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class RouteUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.RouteUpdateResponse) */ {
 public:
  inline RouteUpdateResponse() : RouteUpdateResponse(nullptr) {}
  ~RouteUpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR RouteUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteUpdateResponse(const RouteUpdateResponse& from);
  RouteUpdateResponse(RouteUpdateResponse&& from) noexcept
    : RouteUpdateResponse() {
    *this = ::std::move(from);
  }

  inline RouteUpdateResponse& operator=(const RouteUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteUpdateResponse& operator=(RouteUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const RouteUpdateResponse*>(
               &_RouteUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RouteUpdateResponse& a, RouteUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteUpdateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.RouteUpdateResponse";
  }
  protected:
  explicit RouteUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextupdatehostnameFieldNumber = 1,
    kNextupdateportFieldNumber = 2,
    kNextupdatehostnamehashFieldNumber = 3,
    kCurupdatehostnamehashFieldNumber = 4,
  };
  // required string nextupdatehostname = 1;
  bool has_nextupdatehostname() const;
  private:
  bool _internal_has_nextupdatehostname() const;
  public:
  void clear_nextupdatehostname();
  const std::string& nextupdatehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextupdatehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextupdatehostname();
  PROTOBUF_NODISCARD std::string* release_nextupdatehostname();
  void set_allocated_nextupdatehostname(std::string* nextupdatehostname);
  private:
  const std::string& _internal_nextupdatehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextupdatehostname(const std::string& value);
  std::string* _internal_mutable_nextupdatehostname();
  public:

  // required string nextupdateport = 2;
  bool has_nextupdateport() const;
  private:
  bool _internal_has_nextupdateport() const;
  public:
  void clear_nextupdateport();
  const std::string& nextupdateport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextupdateport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextupdateport();
  PROTOBUF_NODISCARD std::string* release_nextupdateport();
  void set_allocated_nextupdateport(std::string* nextupdateport);
  private:
  const std::string& _internal_nextupdateport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextupdateport(const std::string& value);
  std::string* _internal_mutable_nextupdateport();
  public:

  // required int64 nextupdatehostnamehash = 3;
  bool has_nextupdatehostnamehash() const;
  private:
  bool _internal_has_nextupdatehostnamehash() const;
  public:
  void clear_nextupdatehostnamehash();
  int64_t nextupdatehostnamehash() const;
  void set_nextupdatehostnamehash(int64_t value);
  private:
  int64_t _internal_nextupdatehostnamehash() const;
  void _internal_set_nextupdatehostnamehash(int64_t value);
  public:

  // required int64 curupdatehostnamehash = 4;
  bool has_curupdatehostnamehash() const;
  private:
  bool _internal_has_curupdatehostnamehash() const;
  public:
  void clear_curupdatehostnamehash();
  int64_t curupdatehostnamehash() const;
  void set_curupdatehostnamehash(int64_t value);
  private:
  int64_t _internal_curupdatehostnamehash() const;
  void _internal_set_curupdatehostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.RouteUpdateResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextupdatehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextupdateport_;
  int64_t nextupdatehostnamehash_;
  int64_t curupdatehostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class RouteDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.RouteDeleteRequest) */ {
 public:
  inline RouteDeleteRequest() : RouteDeleteRequest(nullptr) {}
  ~RouteDeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR RouteDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteDeleteRequest(const RouteDeleteRequest& from);
  RouteDeleteRequest(RouteDeleteRequest&& from) noexcept
    : RouteDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RouteDeleteRequest& operator=(const RouteDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteDeleteRequest& operator=(RouteDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RouteDeleteRequest*>(
               &_RouteDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RouteDeleteRequest& a, RouteDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.RouteDeleteRequest";
  }
  protected:
  explicit RouteDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::p2pfilesharing::RouteTableEntry* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >*
      mutable_entry();
  private:
  const ::p2pfilesharing::RouteTableEntry& _internal_entry(int index) const;
  ::p2pfilesharing::RouteTableEntry* _internal_add_entry();
  public:
  const ::p2pfilesharing::RouteTableEntry& entry(int index) const;
  ::p2pfilesharing::RouteTableEntry* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >&
      entry() const;

  // @@protoc_insertion_point(class_scope:p2pfilesharing.RouteDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class HelpJoinRequset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.HelpJoinRequset) */ {
 public:
  inline HelpJoinRequset() : HelpJoinRequset(nullptr) {}
  ~HelpJoinRequset() override;
  explicit PROTOBUF_CONSTEXPR HelpJoinRequset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelpJoinRequset(const HelpJoinRequset& from);
  HelpJoinRequset(HelpJoinRequset&& from) noexcept
    : HelpJoinRequset() {
    *this = ::std::move(from);
  }

  inline HelpJoinRequset& operator=(const HelpJoinRequset& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelpJoinRequset& operator=(HelpJoinRequset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelpJoinRequset& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelpJoinRequset* internal_default_instance() {
    return reinterpret_cast<const HelpJoinRequset*>(
               &_HelpJoinRequset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HelpJoinRequset& a, HelpJoinRequset& b) {
    a.Swap(&b);
  }
  inline void Swap(HelpJoinRequset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelpJoinRequset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelpJoinRequset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelpJoinRequset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelpJoinRequset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelpJoinRequset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelpJoinRequset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.HelpJoinRequset";
  }
  protected:
  explicit HelpJoinRequset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewhostnameFieldNumber = 1,
    kNewportFieldNumber = 2,
    kNewhostnamehashFieldNumber = 3,
  };
  // required string newhostname = 1;
  bool has_newhostname() const;
  private:
  bool _internal_has_newhostname() const;
  public:
  void clear_newhostname();
  const std::string& newhostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newhostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newhostname();
  PROTOBUF_NODISCARD std::string* release_newhostname();
  void set_allocated_newhostname(std::string* newhostname);
  private:
  const std::string& _internal_newhostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newhostname(const std::string& value);
  std::string* _internal_mutable_newhostname();
  public:

  // required string newport = 2;
  bool has_newport() const;
  private:
  bool _internal_has_newport() const;
  public:
  void clear_newport();
  const std::string& newport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newport();
  PROTOBUF_NODISCARD std::string* release_newport();
  void set_allocated_newport(std::string* newport);
  private:
  const std::string& _internal_newport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newport(const std::string& value);
  std::string* _internal_mutable_newport();
  public:

  // required int64 newhostnamehash = 3;
  bool has_newhostnamehash() const;
  private:
  bool _internal_has_newhostnamehash() const;
  public:
  void clear_newhostnamehash();
  int64_t newhostnamehash() const;
  void set_newhostnamehash(int64_t value);
  private:
  int64_t _internal_newhostnamehash() const;
  void _internal_set_newhostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.HelpJoinRequset)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newhostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newport_;
  int64_t newhostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class HelpJoinResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.HelpJoinResponse) */ {
 public:
  inline HelpJoinResponse() : HelpJoinResponse(nullptr) {}
  ~HelpJoinResponse() override;
  explicit PROTOBUF_CONSTEXPR HelpJoinResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelpJoinResponse(const HelpJoinResponse& from);
  HelpJoinResponse(HelpJoinResponse&& from) noexcept
    : HelpJoinResponse() {
    *this = ::std::move(from);
  }

  inline HelpJoinResponse& operator=(const HelpJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelpJoinResponse& operator=(HelpJoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelpJoinResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelpJoinResponse* internal_default_instance() {
    return reinterpret_cast<const HelpJoinResponse*>(
               &_HelpJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HelpJoinResponse& a, HelpJoinResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelpJoinResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelpJoinResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelpJoinResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelpJoinResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelpJoinResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelpJoinResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelpJoinResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.HelpJoinResponse";
  }
  protected:
  explicit HelpJoinResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsiblehostnameFieldNumber = 1,
    kResponsibleportFieldNumber = 2,
    kResponhostnamehashFieldNumber = 3,
  };
  // required string responsiblehostname = 1;
  bool has_responsiblehostname() const;
  private:
  bool _internal_has_responsiblehostname() const;
  public:
  void clear_responsiblehostname();
  const std::string& responsiblehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsiblehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsiblehostname();
  PROTOBUF_NODISCARD std::string* release_responsiblehostname();
  void set_allocated_responsiblehostname(std::string* responsiblehostname);
  private:
  const std::string& _internal_responsiblehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsiblehostname(const std::string& value);
  std::string* _internal_mutable_responsiblehostname();
  public:

  // required string responsibleport = 2;
  bool has_responsibleport() const;
  private:
  bool _internal_has_responsibleport() const;
  public:
  void clear_responsibleport();
  const std::string& responsibleport() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_responsibleport(ArgT0&& arg0, ArgT... args);
  std::string* mutable_responsibleport();
  PROTOBUF_NODISCARD std::string* release_responsibleport();
  void set_allocated_responsibleport(std::string* responsibleport);
  private:
  const std::string& _internal_responsibleport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsibleport(const std::string& value);
  std::string* _internal_mutable_responsibleport();
  public:

  // required int64 responhostnamehash = 3;
  bool has_responhostnamehash() const;
  private:
  bool _internal_has_responhostnamehash() const;
  public:
  void clear_responhostnamehash();
  int64_t responhostnamehash() const;
  void set_responhostnamehash(int64_t value);
  private:
  int64_t _internal_responhostnamehash() const;
  void _internal_set_responhostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.HelpJoinResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsiblehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsibleport_;
  int64_t responhostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class LookupNodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.LookupNodeResponse) */ {
 public:
  inline LookupNodeResponse() : LookupNodeResponse(nullptr) {}
  ~LookupNodeResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupNodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupNodeResponse(const LookupNodeResponse& from);
  LookupNodeResponse(LookupNodeResponse&& from) noexcept
    : LookupNodeResponse() {
    *this = ::std::move(from);
  }

  inline LookupNodeResponse& operator=(const LookupNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupNodeResponse& operator=(LookupNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupNodeResponse* internal_default_instance() {
    return reinterpret_cast<const LookupNodeResponse*>(
               &_LookupNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LookupNodeResponse& a, LookupNodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupNodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupNodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupNodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupNodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupNodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupNodeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupNodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.LookupNodeResponse";
  }
  protected:
  explicit LookupNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kPortFieldNumber = 2,
    kHostnamehashFieldNumber = 3,
  };
  // required string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // required string port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const std::string& port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* port);
  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(const std::string& value);
  std::string* _internal_mutable_port();
  public:

  // required int64 hostnamehash = 3;
  bool has_hostnamehash() const;
  private:
  bool _internal_has_hostnamehash() const;
  public:
  void clear_hostnamehash();
  int64_t hostnamehash() const;
  void set_hostnamehash(int64_t value);
  private:
  int64_t _internal_hostnamehash() const;
  void _internal_set_hostnamehash(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.LookupNodeResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
  int64_t hostnamehash_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class NodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.NodeRequest) */ {
 public:
  inline NodeRequest() : NodeRequest(nullptr) {}
  ~NodeRequest() override;
  explicit PROTOBUF_CONSTEXPR NodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeRequest(const NodeRequest& from);
  NodeRequest(NodeRequest&& from) noexcept
    : NodeRequest() {
    *this = ::std::move(from);
  }

  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
               &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NodeRequest& a, NodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.NodeRequest";
  }
  protected:
  explicit NodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddfileFieldNumber = 2,
    kLookupFieldNumber = 3,
    kDeletefileFieldNumber = 4,
    kDownloadFieldNumber = 5,
    kJoinFieldNumber = 6,
    kUpdaterouteFieldNumber = 7,
    kDeleterouteFieldNumber = 8,
    kHelpjoinFieldNumber = 9,
    kTypeFieldNumber = 1,
  };
  // optional .p2pfilesharing.AddFileRequest addfile = 2;
  bool has_addfile() const;
  private:
  bool _internal_has_addfile() const;
  public:
  void clear_addfile();
  const ::p2pfilesharing::AddFileRequest& addfile() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::AddFileRequest* release_addfile();
  ::p2pfilesharing::AddFileRequest* mutable_addfile();
  void set_allocated_addfile(::p2pfilesharing::AddFileRequest* addfile);
  private:
  const ::p2pfilesharing::AddFileRequest& _internal_addfile() const;
  ::p2pfilesharing::AddFileRequest* _internal_mutable_addfile();
  public:
  void unsafe_arena_set_allocated_addfile(
      ::p2pfilesharing::AddFileRequest* addfile);
  ::p2pfilesharing::AddFileRequest* unsafe_arena_release_addfile();

  // optional .p2pfilesharing.LookupFileRequest lookup = 3;
  bool has_lookup() const;
  private:
  bool _internal_has_lookup() const;
  public:
  void clear_lookup();
  const ::p2pfilesharing::LookupFileRequest& lookup() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::LookupFileRequest* release_lookup();
  ::p2pfilesharing::LookupFileRequest* mutable_lookup();
  void set_allocated_lookup(::p2pfilesharing::LookupFileRequest* lookup);
  private:
  const ::p2pfilesharing::LookupFileRequest& _internal_lookup() const;
  ::p2pfilesharing::LookupFileRequest* _internal_mutable_lookup();
  public:
  void unsafe_arena_set_allocated_lookup(
      ::p2pfilesharing::LookupFileRequest* lookup);
  ::p2pfilesharing::LookupFileRequest* unsafe_arena_release_lookup();

  // optional .p2pfilesharing.DeleteFileRequest deletefile = 4;
  bool has_deletefile() const;
  private:
  bool _internal_has_deletefile() const;
  public:
  void clear_deletefile();
  const ::p2pfilesharing::DeleteFileRequest& deletefile() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::DeleteFileRequest* release_deletefile();
  ::p2pfilesharing::DeleteFileRequest* mutable_deletefile();
  void set_allocated_deletefile(::p2pfilesharing::DeleteFileRequest* deletefile);
  private:
  const ::p2pfilesharing::DeleteFileRequest& _internal_deletefile() const;
  ::p2pfilesharing::DeleteFileRequest* _internal_mutable_deletefile();
  public:
  void unsafe_arena_set_allocated_deletefile(
      ::p2pfilesharing::DeleteFileRequest* deletefile);
  ::p2pfilesharing::DeleteFileRequest* unsafe_arena_release_deletefile();

  // optional .p2pfilesharing.DownloadRequest download = 5;
  bool has_download() const;
  private:
  bool _internal_has_download() const;
  public:
  void clear_download();
  const ::p2pfilesharing::DownloadRequest& download() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::DownloadRequest* release_download();
  ::p2pfilesharing::DownloadRequest* mutable_download();
  void set_allocated_download(::p2pfilesharing::DownloadRequest* download);
  private:
  const ::p2pfilesharing::DownloadRequest& _internal_download() const;
  ::p2pfilesharing::DownloadRequest* _internal_mutable_download();
  public:
  void unsafe_arena_set_allocated_download(
      ::p2pfilesharing::DownloadRequest* download);
  ::p2pfilesharing::DownloadRequest* unsafe_arena_release_download();

  // optional .p2pfilesharing.JoinRequest join = 6;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::p2pfilesharing::JoinRequest& join() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::JoinRequest* release_join();
  ::p2pfilesharing::JoinRequest* mutable_join();
  void set_allocated_join(::p2pfilesharing::JoinRequest* join);
  private:
  const ::p2pfilesharing::JoinRequest& _internal_join() const;
  ::p2pfilesharing::JoinRequest* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::p2pfilesharing::JoinRequest* join);
  ::p2pfilesharing::JoinRequest* unsafe_arena_release_join();

  // optional .p2pfilesharing.RouteUpdateRequest updateroute = 7;
  bool has_updateroute() const;
  private:
  bool _internal_has_updateroute() const;
  public:
  void clear_updateroute();
  const ::p2pfilesharing::RouteUpdateRequest& updateroute() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::RouteUpdateRequest* release_updateroute();
  ::p2pfilesharing::RouteUpdateRequest* mutable_updateroute();
  void set_allocated_updateroute(::p2pfilesharing::RouteUpdateRequest* updateroute);
  private:
  const ::p2pfilesharing::RouteUpdateRequest& _internal_updateroute() const;
  ::p2pfilesharing::RouteUpdateRequest* _internal_mutable_updateroute();
  public:
  void unsafe_arena_set_allocated_updateroute(
      ::p2pfilesharing::RouteUpdateRequest* updateroute);
  ::p2pfilesharing::RouteUpdateRequest* unsafe_arena_release_updateroute();

  // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 8;
  bool has_deleteroute() const;
  private:
  bool _internal_has_deleteroute() const;
  public:
  void clear_deleteroute();
  const ::p2pfilesharing::RouteDeleteRequest& deleteroute() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::RouteDeleteRequest* release_deleteroute();
  ::p2pfilesharing::RouteDeleteRequest* mutable_deleteroute();
  void set_allocated_deleteroute(::p2pfilesharing::RouteDeleteRequest* deleteroute);
  private:
  const ::p2pfilesharing::RouteDeleteRequest& _internal_deleteroute() const;
  ::p2pfilesharing::RouteDeleteRequest* _internal_mutable_deleteroute();
  public:
  void unsafe_arena_set_allocated_deleteroute(
      ::p2pfilesharing::RouteDeleteRequest* deleteroute);
  ::p2pfilesharing::RouteDeleteRequest* unsafe_arena_release_deleteroute();

  // optional .p2pfilesharing.HelpJoinRequset helpjoin = 9;
  bool has_helpjoin() const;
  private:
  bool _internal_has_helpjoin() const;
  public:
  void clear_helpjoin();
  const ::p2pfilesharing::HelpJoinRequset& helpjoin() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::HelpJoinRequset* release_helpjoin();
  ::p2pfilesharing::HelpJoinRequset* mutable_helpjoin();
  void set_allocated_helpjoin(::p2pfilesharing::HelpJoinRequset* helpjoin);
  private:
  const ::p2pfilesharing::HelpJoinRequset& _internal_helpjoin() const;
  ::p2pfilesharing::HelpJoinRequset* _internal_mutable_helpjoin();
  public:
  void unsafe_arena_set_allocated_helpjoin(
      ::p2pfilesharing::HelpJoinRequset* helpjoin);
  ::p2pfilesharing::HelpJoinRequset* unsafe_arena_release_helpjoin();

  // required int64 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int64_t type() const;
  void set_type(int64_t value);
  private:
  int64_t _internal_type() const;
  void _internal_set_type(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.NodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::p2pfilesharing::AddFileRequest* addfile_;
  ::p2pfilesharing::LookupFileRequest* lookup_;
  ::p2pfilesharing::DeleteFileRequest* deletefile_;
  ::p2pfilesharing::DownloadRequest* download_;
  ::p2pfilesharing::JoinRequest* join_;
  ::p2pfilesharing::RouteUpdateRequest* updateroute_;
  ::p2pfilesharing::RouteDeleteRequest* deleteroute_;
  ::p2pfilesharing::HelpJoinRequset* helpjoin_;
  int64_t type_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// -------------------------------------------------------------------

class NodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:p2pfilesharing.NodeResponse) */ {
 public:
  inline NodeResponse() : NodeResponse(nullptr) {}
  ~NodeResponse() override;
  explicit PROTOBUF_CONSTEXPR NodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeResponse(const NodeResponse& from);
  NodeResponse(NodeResponse&& from) noexcept
    : NodeResponse() {
    *this = ::std::move(from);
  }

  inline NodeResponse& operator=(const NodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeResponse& operator=(NodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeResponse*>(
               &_NodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NodeResponse& a, NodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "p2pfilesharing.NodeResponse";
  }
  protected:
  explicit NodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLookupFieldNumber = 2,
    kFileinforspFieldNumber = 3,
    kRouteinitFieldNumber = 4,
    kFiletableFieldNumber = 5,
    kHelpjoinFieldNumber = 6,
    kUpdaterouteFieldNumber = 7,
    kLookupnodeFieldNumber = 8,
    kTypeFieldNumber = 1,
  };
  // optional .p2pfilesharing.LookupFileResponse lookup = 2;
  bool has_lookup() const;
  private:
  bool _internal_has_lookup() const;
  public:
  void clear_lookup();
  const ::p2pfilesharing::LookupFileResponse& lookup() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::LookupFileResponse* release_lookup();
  ::p2pfilesharing::LookupFileResponse* mutable_lookup();
  void set_allocated_lookup(::p2pfilesharing::LookupFileResponse* lookup);
  private:
  const ::p2pfilesharing::LookupFileResponse& _internal_lookup() const;
  ::p2pfilesharing::LookupFileResponse* _internal_mutable_lookup();
  public:
  void unsafe_arena_set_allocated_lookup(
      ::p2pfilesharing::LookupFileResponse* lookup);
  ::p2pfilesharing::LookupFileResponse* unsafe_arena_release_lookup();

  // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
  bool has_fileinforsp() const;
  private:
  bool _internal_has_fileinforsp() const;
  public:
  void clear_fileinforsp();
  const ::p2pfilesharing::FileInfoResponse& fileinforsp() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::FileInfoResponse* release_fileinforsp();
  ::p2pfilesharing::FileInfoResponse* mutable_fileinforsp();
  void set_allocated_fileinforsp(::p2pfilesharing::FileInfoResponse* fileinforsp);
  private:
  const ::p2pfilesharing::FileInfoResponse& _internal_fileinforsp() const;
  ::p2pfilesharing::FileInfoResponse* _internal_mutable_fileinforsp();
  public:
  void unsafe_arena_set_allocated_fileinforsp(
      ::p2pfilesharing::FileInfoResponse* fileinforsp);
  ::p2pfilesharing::FileInfoResponse* unsafe_arena_release_fileinforsp();

  // optional .p2pfilesharing.RouteTableInit routeinit = 4;
  bool has_routeinit() const;
  private:
  bool _internal_has_routeinit() const;
  public:
  void clear_routeinit();
  const ::p2pfilesharing::RouteTableInit& routeinit() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::RouteTableInit* release_routeinit();
  ::p2pfilesharing::RouteTableInit* mutable_routeinit();
  void set_allocated_routeinit(::p2pfilesharing::RouteTableInit* routeinit);
  private:
  const ::p2pfilesharing::RouteTableInit& _internal_routeinit() const;
  ::p2pfilesharing::RouteTableInit* _internal_mutable_routeinit();
  public:
  void unsafe_arena_set_allocated_routeinit(
      ::p2pfilesharing::RouteTableInit* routeinit);
  ::p2pfilesharing::RouteTableInit* unsafe_arena_release_routeinit();

  // optional .p2pfilesharing.FileTable filetable = 5;
  bool has_filetable() const;
  private:
  bool _internal_has_filetable() const;
  public:
  void clear_filetable();
  const ::p2pfilesharing::FileTable& filetable() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::FileTable* release_filetable();
  ::p2pfilesharing::FileTable* mutable_filetable();
  void set_allocated_filetable(::p2pfilesharing::FileTable* filetable);
  private:
  const ::p2pfilesharing::FileTable& _internal_filetable() const;
  ::p2pfilesharing::FileTable* _internal_mutable_filetable();
  public:
  void unsafe_arena_set_allocated_filetable(
      ::p2pfilesharing::FileTable* filetable);
  ::p2pfilesharing::FileTable* unsafe_arena_release_filetable();

  // optional .p2pfilesharing.HelpJoinResponse helpjoin = 6;
  bool has_helpjoin() const;
  private:
  bool _internal_has_helpjoin() const;
  public:
  void clear_helpjoin();
  const ::p2pfilesharing::HelpJoinResponse& helpjoin() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::HelpJoinResponse* release_helpjoin();
  ::p2pfilesharing::HelpJoinResponse* mutable_helpjoin();
  void set_allocated_helpjoin(::p2pfilesharing::HelpJoinResponse* helpjoin);
  private:
  const ::p2pfilesharing::HelpJoinResponse& _internal_helpjoin() const;
  ::p2pfilesharing::HelpJoinResponse* _internal_mutable_helpjoin();
  public:
  void unsafe_arena_set_allocated_helpjoin(
      ::p2pfilesharing::HelpJoinResponse* helpjoin);
  ::p2pfilesharing::HelpJoinResponse* unsafe_arena_release_helpjoin();

  // optional .p2pfilesharing.RouteUpdateResponse updateroute = 7;
  bool has_updateroute() const;
  private:
  bool _internal_has_updateroute() const;
  public:
  void clear_updateroute();
  const ::p2pfilesharing::RouteUpdateResponse& updateroute() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::RouteUpdateResponse* release_updateroute();
  ::p2pfilesharing::RouteUpdateResponse* mutable_updateroute();
  void set_allocated_updateroute(::p2pfilesharing::RouteUpdateResponse* updateroute);
  private:
  const ::p2pfilesharing::RouteUpdateResponse& _internal_updateroute() const;
  ::p2pfilesharing::RouteUpdateResponse* _internal_mutable_updateroute();
  public:
  void unsafe_arena_set_allocated_updateroute(
      ::p2pfilesharing::RouteUpdateResponse* updateroute);
  ::p2pfilesharing::RouteUpdateResponse* unsafe_arena_release_updateroute();

  // optional .p2pfilesharing.LookupNodeResponse lookupnode = 8;
  bool has_lookupnode() const;
  private:
  bool _internal_has_lookupnode() const;
  public:
  void clear_lookupnode();
  const ::p2pfilesharing::LookupNodeResponse& lookupnode() const;
  PROTOBUF_NODISCARD ::p2pfilesharing::LookupNodeResponse* release_lookupnode();
  ::p2pfilesharing::LookupNodeResponse* mutable_lookupnode();
  void set_allocated_lookupnode(::p2pfilesharing::LookupNodeResponse* lookupnode);
  private:
  const ::p2pfilesharing::LookupNodeResponse& _internal_lookupnode() const;
  ::p2pfilesharing::LookupNodeResponse* _internal_mutable_lookupnode();
  public:
  void unsafe_arena_set_allocated_lookupnode(
      ::p2pfilesharing::LookupNodeResponse* lookupnode);
  ::p2pfilesharing::LookupNodeResponse* unsafe_arena_release_lookupnode();

  // required int64 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int64_t type() const;
  void set_type(int64_t value);
  private:
  int64_t _internal_type() const;
  void _internal_set_type(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:p2pfilesharing.NodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::p2pfilesharing::LookupFileResponse* lookup_;
  ::p2pfilesharing::FileInfoResponse* fileinforsp_;
  ::p2pfilesharing::RouteTableInit* routeinit_;
  ::p2pfilesharing::FileTable* filetable_;
  ::p2pfilesharing::HelpJoinResponse* helpjoin_;
  ::p2pfilesharing::RouteUpdateResponse* updateroute_;
  ::p2pfilesharing::LookupNodeResponse* lookupnode_;
  int64_t type_;
  friend struct ::TableStruct_P2P_5fProtocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddFileRequest

// required int64 filenamehash = 1;
inline bool AddFileRequest::_internal_has_filenamehash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AddFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void AddFileRequest::clear_filenamehash() {
  filenamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t AddFileRequest::_internal_filenamehash() const {
  return filenamehash_;
}
inline int64_t AddFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.AddFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void AddFileRequest::_internal_set_filenamehash(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  filenamehash_ = value;
}
inline void AddFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.AddFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool AddFileRequest::_internal_has_sourcehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void AddFileRequest::clear_sourcehostname() {
  sourcehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.AddFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.AddFileRequest.sourcehostname)
}
inline std::string* AddFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.AddFileRequest.sourcehostname)
  return _s;
}
inline const std::string& AddFileRequest::_internal_sourcehostname() const {
  return sourcehostname_.Get();
}
inline void AddFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFileRequest::_internal_mutable_sourcehostname() {
  _has_bits_[0] |= 0x00000001u;
  return sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.AddFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AddFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.AddFileRequest.sourcehostname)
}

// -------------------------------------------------------------------

// LookupFileRequest

// required int64 filenamehash = 1;
inline bool LookupFileRequest::_internal_has_filenamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LookupFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void LookupFileRequest::clear_filenamehash() {
  filenamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t LookupFileRequest::_internal_filenamehash() const {
  return filenamehash_;
}
inline int64_t LookupFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void LookupFileRequest::_internal_set_filenamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  filenamehash_ = value;
}
inline void LookupFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool LookupFileRequest::_internal_has_sourcehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LookupFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void LookupFileRequest::clear_sourcehostname() {
  sourcehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.sourcehostname)
}
inline std::string* LookupFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileRequest.sourcehostname)
  return _s;
}
inline const std::string& LookupFileRequest::_internal_sourcehostname() const {
  return sourcehostname_.Get();
}
inline void LookupFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileRequest::_internal_mutable_sourcehostname() {
  _has_bits_[0] |= 0x00000001u;
  return sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool LookupFileRequest::_internal_has_sourceport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LookupFileRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void LookupFileRequest::clear_sourceport() {
  sourceport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LookupFileRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileRequest.sourceport)
}
inline std::string* LookupFileRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileRequest.sourceport)
  return _s;
}
inline const std::string& LookupFileRequest::_internal_sourceport() const {
  return sourceport_.Get();
}
inline void LookupFileRequest::_internal_set_sourceport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileRequest::_internal_mutable_sourceport() {
  _has_bits_[0] |= 0x00000002u;
  return sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileRequest.sourceport)
}

// -------------------------------------------------------------------

// DeleteFileRequest

// required int64 filenamehash = 1;
inline bool DeleteFileRequest::_internal_has_filenamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void DeleteFileRequest::clear_filenamehash() {
  filenamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t DeleteFileRequest::_internal_filenamehash() const {
  return filenamehash_;
}
inline int64_t DeleteFileRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.filenamehash)
  return _internal_filenamehash();
}
inline void DeleteFileRequest::_internal_set_filenamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  filenamehash_ = value;
}
inline void DeleteFileRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool DeleteFileRequest::_internal_has_sourcehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void DeleteFileRequest::clear_sourcehostname() {
  sourcehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteFileRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.sourcehostname)
}
inline std::string* DeleteFileRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DeleteFileRequest.sourcehostname)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_sourcehostname() const {
  return sourcehostname_.Get();
}
inline void DeleteFileRequest::_internal_set_sourcehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_sourcehostname() {
  _has_bits_[0] |= 0x00000001u;
  return sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DeleteFileRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteFileRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DeleteFileRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool DeleteFileRequest::_internal_has_sourceport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeleteFileRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void DeleteFileRequest::clear_sourceport() {
  sourceport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeleteFileRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DeleteFileRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DeleteFileRequest.sourceport)
}
inline std::string* DeleteFileRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DeleteFileRequest.sourceport)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_sourceport() const {
  return sourceport_.Get();
}
inline void DeleteFileRequest::_internal_set_sourceport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_sourceport() {
  _has_bits_[0] |= 0x00000002u;
  return sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DeleteFileRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteFileRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DeleteFileRequest.sourceport)
}

// -------------------------------------------------------------------

// LookupFileResponse

// required bool ifexists = 1;
inline bool LookupFileResponse::_internal_has_ifexists() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ifexists() const {
  return _internal_has_ifexists();
}
inline void LookupFileResponse::clear_ifexists() {
  ifexists_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool LookupFileResponse::_internal_ifexists() const {
  return ifexists_;
}
inline bool LookupFileResponse::ifexists() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ifexists)
  return _internal_ifexists();
}
inline void LookupFileResponse::_internal_set_ifexists(bool value) {
  _has_bits_[0] |= 0x00000010u;
  ifexists_ = value;
}
inline void LookupFileResponse::set_ifexists(bool value) {
  _internal_set_ifexists(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ifexists)
}

// required string successorhostname = 2;
inline bool LookupFileResponse::_internal_has_successorhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LookupFileResponse::has_successorhostname() const {
  return _internal_has_successorhostname();
}
inline void LookupFileResponse::clear_successorhostname() {
  successorhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupFileResponse::successorhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.successorhostname)
  return _internal_successorhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_successorhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 successorhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.successorhostname)
}
inline std::string* LookupFileResponse::mutable_successorhostname() {
  std::string* _s = _internal_mutable_successorhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.successorhostname)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_successorhostname() const {
  return successorhostname_.Get();
}
inline void LookupFileResponse::_internal_set_successorhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  successorhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_successorhostname() {
  _has_bits_[0] |= 0x00000001u;
  return successorhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_successorhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.successorhostname)
  if (!_internal_has_successorhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = successorhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successorhostname_.IsDefault()) {
    successorhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_successorhostname(std::string* successorhostname) {
  if (successorhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  successorhostname_.SetAllocated(successorhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successorhostname_.IsDefault()) {
    successorhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.successorhostname)
}

// required string successorport = 3;
inline bool LookupFileResponse::_internal_has_successorport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LookupFileResponse::has_successorport() const {
  return _internal_has_successorport();
}
inline void LookupFileResponse::clear_successorport() {
  successorport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LookupFileResponse::successorport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.successorport)
  return _internal_successorport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_successorport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 successorport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.successorport)
}
inline std::string* LookupFileResponse::mutable_successorport() {
  std::string* _s = _internal_mutable_successorport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.successorport)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_successorport() const {
  return successorport_.Get();
}
inline void LookupFileResponse::_internal_set_successorport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  successorport_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_successorport() {
  _has_bits_[0] |= 0x00000002u;
  return successorport_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_successorport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.successorport)
  if (!_internal_has_successorport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = successorport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successorport_.IsDefault()) {
    successorport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_successorport(std::string* successorport) {
  if (successorport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  successorport_.SetAllocated(successorport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (successorport_.IsDefault()) {
    successorport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.successorport)
}

// optional string ownerhostname = 4;
inline bool LookupFileResponse::_internal_has_ownerhostname() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void LookupFileResponse::clear_ownerhostname() {
  ownerhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LookupFileResponse::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ownerhostname)
}
inline std::string* LookupFileResponse::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.ownerhostname)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_ownerhostname() const {
  return ownerhostname_.Get();
}
inline void LookupFileResponse::_internal_set_ownerhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_ownerhostname() {
  _has_bits_[0] |= 0x00000004u;
  return ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.ownerhostname)
}

// optional string ownerport = 5;
inline bool LookupFileResponse::_internal_has_ownerport() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LookupFileResponse::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void LookupFileResponse::clear_ownerport() {
  ownerport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LookupFileResponse::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupFileResponse.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupFileResponse::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupFileResponse.ownerport)
}
inline std::string* LookupFileResponse::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupFileResponse.ownerport)
  return _s;
}
inline const std::string& LookupFileResponse::_internal_ownerport() const {
  return ownerport_.Get();
}
inline void LookupFileResponse::_internal_set_ownerport(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupFileResponse::_internal_mutable_ownerport() {
  _has_bits_[0] |= 0x00000008u;
  return ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupFileResponse::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupFileResponse.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupFileResponse::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupFileResponse.ownerport)
}

// -------------------------------------------------------------------

// FileInfoResponse

// required string ownerhostname = 1;
inline bool FileInfoResponse::_internal_has_ownerhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileInfoResponse::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void FileInfoResponse::clear_ownerhostname() {
  ownerhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileInfoResponse::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileInfoResponse.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfoResponse::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.FileInfoResponse.ownerhostname)
}
inline std::string* FileInfoResponse::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.FileInfoResponse.ownerhostname)
  return _s;
}
inline const std::string& FileInfoResponse::_internal_ownerhostname() const {
  return ownerhostname_.Get();
}
inline void FileInfoResponse::_internal_set_ownerhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfoResponse::_internal_mutable_ownerhostname() {
  _has_bits_[0] |= 0x00000001u;
  return ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfoResponse::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.FileInfoResponse.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileInfoResponse::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.FileInfoResponse.ownerhostname)
}

// required string ownerport = 2;
inline bool FileInfoResponse::_internal_has_ownerport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileInfoResponse::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void FileInfoResponse::clear_ownerport() {
  ownerport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileInfoResponse::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileInfoResponse.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfoResponse::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.FileInfoResponse.ownerport)
}
inline std::string* FileInfoResponse::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.FileInfoResponse.ownerport)
  return _s;
}
inline const std::string& FileInfoResponse::_internal_ownerport() const {
  return ownerport_.Get();
}
inline void FileInfoResponse::_internal_set_ownerport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfoResponse::_internal_mutable_ownerport() {
  _has_bits_[0] |= 0x00000002u;
  return ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfoResponse::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.FileInfoResponse.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileInfoResponse::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.FileInfoResponse.ownerport)
}

// -------------------------------------------------------------------

// DownloadRequest

// required int64 filenamehash = 1;
inline bool DownloadRequest::_internal_has_filenamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DownloadRequest::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void DownloadRequest::clear_filenamehash() {
  filenamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t DownloadRequest::_internal_filenamehash() const {
  return filenamehash_;
}
inline int64_t DownloadRequest::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DownloadRequest.filenamehash)
  return _internal_filenamehash();
}
inline void DownloadRequest::_internal_set_filenamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  filenamehash_ = value;
}
inline void DownloadRequest::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.DownloadRequest.filenamehash)
}

// required string sourcehostname = 2;
inline bool DownloadRequest::_internal_has_sourcehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadRequest::has_sourcehostname() const {
  return _internal_has_sourcehostname();
}
inline void DownloadRequest::clear_sourcehostname() {
  sourcehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadRequest::sourcehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DownloadRequest.sourcehostname)
  return _internal_sourcehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadRequest::set_sourcehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sourcehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DownloadRequest.sourcehostname)
}
inline std::string* DownloadRequest::mutable_sourcehostname() {
  std::string* _s = _internal_mutable_sourcehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DownloadRequest.sourcehostname)
  return _s;
}
inline const std::string& DownloadRequest::_internal_sourcehostname() const {
  return sourcehostname_.Get();
}
inline void DownloadRequest::_internal_set_sourcehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sourcehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadRequest::_internal_mutable_sourcehostname() {
  _has_bits_[0] |= 0x00000001u;
  return sourcehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadRequest::release_sourcehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DownloadRequest.sourcehostname)
  if (!_internal_has_sourcehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sourcehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadRequest::set_allocated_sourcehostname(std::string* sourcehostname) {
  if (sourcehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sourcehostname_.SetAllocated(sourcehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcehostname_.IsDefault()) {
    sourcehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DownloadRequest.sourcehostname)
}

// required string sourceport = 3;
inline bool DownloadRequest::_internal_has_sourceport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DownloadRequest::has_sourceport() const {
  return _internal_has_sourceport();
}
inline void DownloadRequest::clear_sourceport() {
  sourceport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DownloadRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.DownloadRequest.sourceport)
  return _internal_sourceport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadRequest::set_sourceport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sourceport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.DownloadRequest.sourceport)
}
inline std::string* DownloadRequest::mutable_sourceport() {
  std::string* _s = _internal_mutable_sourceport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.DownloadRequest.sourceport)
  return _s;
}
inline const std::string& DownloadRequest::_internal_sourceport() const {
  return sourceport_.Get();
}
inline void DownloadRequest::_internal_set_sourceport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sourceport_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadRequest::_internal_mutable_sourceport() {
  _has_bits_[0] |= 0x00000002u;
  return sourceport_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadRequest::release_sourceport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.DownloadRequest.sourceport)
  if (!_internal_has_sourceport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sourceport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadRequest::set_allocated_sourceport(std::string* sourceport) {
  if (sourceport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sourceport_.SetAllocated(sourceport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceport_.IsDefault()) {
    sourceport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.DownloadRequest.sourceport)
}

// -------------------------------------------------------------------

// JoinRequest

// required string newhostname = 1;
inline bool JoinRequest::_internal_has_newhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinRequest::has_newhostname() const {
  return _internal_has_newhostname();
}
inline void JoinRequest::clear_newhostname() {
  newhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JoinRequest::newhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.JoinRequest.newhostname)
  return _internal_newhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRequest::set_newhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 newhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.JoinRequest.newhostname)
}
inline std::string* JoinRequest::mutable_newhostname() {
  std::string* _s = _internal_mutable_newhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.JoinRequest.newhostname)
  return _s;
}
inline const std::string& JoinRequest::_internal_newhostname() const {
  return newhostname_.Get();
}
inline void JoinRequest::_internal_set_newhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  newhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRequest::_internal_mutable_newhostname() {
  _has_bits_[0] |= 0x00000001u;
  return newhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRequest::release_newhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.JoinRequest.newhostname)
  if (!_internal_has_newhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = newhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinRequest::set_allocated_newhostname(std::string* newhostname) {
  if (newhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  newhostname_.SetAllocated(newhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.JoinRequest.newhostname)
}

// required string newport = 2;
inline bool JoinRequest::_internal_has_newport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinRequest::has_newport() const {
  return _internal_has_newport();
}
inline void JoinRequest::clear_newport() {
  newport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JoinRequest::newport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.JoinRequest.newport)
  return _internal_newport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRequest::set_newport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 newport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.JoinRequest.newport)
}
inline std::string* JoinRequest::mutable_newport() {
  std::string* _s = _internal_mutable_newport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.JoinRequest.newport)
  return _s;
}
inline const std::string& JoinRequest::_internal_newport() const {
  return newport_.Get();
}
inline void JoinRequest::_internal_set_newport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  newport_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRequest::_internal_mutable_newport() {
  _has_bits_[0] |= 0x00000002u;
  return newport_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRequest::release_newport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.JoinRequest.newport)
  if (!_internal_has_newport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = newport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JoinRequest::set_allocated_newport(std::string* newport) {
  if (newport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  newport_.SetAllocated(newport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.JoinRequest.newport)
}

// required int64 newhostnamehash = 3;
inline bool JoinRequest::_internal_has_newhostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JoinRequest::has_newhostnamehash() const {
  return _internal_has_newhostnamehash();
}
inline void JoinRequest::clear_newhostnamehash() {
  newhostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t JoinRequest::_internal_newhostnamehash() const {
  return newhostnamehash_;
}
inline int64_t JoinRequest::newhostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.JoinRequest.newhostnamehash)
  return _internal_newhostnamehash();
}
inline void JoinRequest::_internal_set_newhostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  newhostnamehash_ = value;
}
inline void JoinRequest::set_newhostnamehash(int64_t value) {
  _internal_set_newhostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.JoinRequest.newhostnamehash)
}

// -------------------------------------------------------------------

// RouteTableInit

// repeated .p2pfilesharing.RouteTableEntry entry = 1;
inline int RouteTableInit::_internal_entry_size() const {
  return entry_.size();
}
inline int RouteTableInit::entry_size() const {
  return _internal_entry_size();
}
inline void RouteTableInit::clear_entry() {
  entry_.Clear();
}
inline ::p2pfilesharing::RouteTableEntry* RouteTableInit::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteTableInit.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >*
RouteTableInit::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.RouteTableInit.entry)
  return &entry_;
}
inline const ::p2pfilesharing::RouteTableEntry& RouteTableInit::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::p2pfilesharing::RouteTableEntry& RouteTableInit::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteTableInit.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::RouteTableEntry* RouteTableInit::_internal_add_entry() {
  return entry_.Add();
}
inline ::p2pfilesharing::RouteTableEntry* RouteTableInit::add_entry() {
  ::p2pfilesharing::RouteTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.RouteTableInit.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >&
RouteTableInit::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.RouteTableInit.entry)
  return entry_;
}

// -------------------------------------------------------------------

// RouteTableEntry

// required string hostname = 1;
inline bool RouteTableEntry::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RouteTableEntry::has_hostname() const {
  return _internal_has_hostname();
}
inline void RouteTableEntry::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouteTableEntry::hostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteTableEntry.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteTableEntry::set_hostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteTableEntry.hostname)
}
inline std::string* RouteTableEntry::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteTableEntry.hostname)
  return _s;
}
inline const std::string& RouteTableEntry::_internal_hostname() const {
  return hostname_.Get();
}
inline void RouteTableEntry::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteTableEntry::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteTableEntry::release_hostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteTableEntry.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteTableEntry::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteTableEntry.hostname)
}

// required string port = 2;
inline bool RouteTableEntry::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RouteTableEntry::has_port() const {
  return _internal_has_port();
}
inline void RouteTableEntry::clear_port() {
  port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RouteTableEntry::port() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteTableEntry.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteTableEntry::set_port(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteTableEntry.port)
}
inline std::string* RouteTableEntry::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteTableEntry.port)
  return _s;
}
inline const std::string& RouteTableEntry::_internal_port() const {
  return port_.Get();
}
inline void RouteTableEntry::_internal_set_port(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  port_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteTableEntry::_internal_mutable_port() {
  _has_bits_[0] |= 0x00000002u;
  return port_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteTableEntry::release_port() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteTableEntry.port)
  if (!_internal_has_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault()) {
    port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteTableEntry::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault()) {
    port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteTableEntry.port)
}

// required int64 hostnamehash = 3;
inline bool RouteTableEntry::_internal_has_hostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RouteTableEntry::has_hostnamehash() const {
  return _internal_has_hostnamehash();
}
inline void RouteTableEntry::clear_hostnamehash() {
  hostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t RouteTableEntry::_internal_hostnamehash() const {
  return hostnamehash_;
}
inline int64_t RouteTableEntry::hostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteTableEntry.hostnamehash)
  return _internal_hostnamehash();
}
inline void RouteTableEntry::_internal_set_hostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  hostnamehash_ = value;
}
inline void RouteTableEntry::set_hostnamehash(int64_t value) {
  _internal_set_hostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteTableEntry.hostnamehash)
}

// -------------------------------------------------------------------

// FileTable

// repeated .p2pfilesharing.FileTableEntry entry = 1;
inline int FileTable::_internal_entry_size() const {
  return entry_.size();
}
inline int FileTable::entry_size() const {
  return _internal_entry_size();
}
inline void FileTable::clear_entry() {
  entry_.Clear();
}
inline ::p2pfilesharing::FileTableEntry* FileTable::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.FileTable.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::FileTableEntry >*
FileTable::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.FileTable.entry)
  return &entry_;
}
inline const ::p2pfilesharing::FileTableEntry& FileTable::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::p2pfilesharing::FileTableEntry& FileTable::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileTable.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::FileTableEntry* FileTable::_internal_add_entry() {
  return entry_.Add();
}
inline ::p2pfilesharing::FileTableEntry* FileTable::add_entry() {
  ::p2pfilesharing::FileTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.FileTable.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::FileTableEntry >&
FileTable::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.FileTable.entry)
  return entry_;
}

// -------------------------------------------------------------------

// FileTableEntry

// required int64 filenamehash = 1;
inline bool FileTableEntry::_internal_has_filenamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileTableEntry::has_filenamehash() const {
  return _internal_has_filenamehash();
}
inline void FileTableEntry::clear_filenamehash() {
  filenamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t FileTableEntry::_internal_filenamehash() const {
  return filenamehash_;
}
inline int64_t FileTableEntry::filenamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileTableEntry.filenamehash)
  return _internal_filenamehash();
}
inline void FileTableEntry::_internal_set_filenamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  filenamehash_ = value;
}
inline void FileTableEntry::set_filenamehash(int64_t value) {
  _internal_set_filenamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.FileTableEntry.filenamehash)
}

// required string ownerhostname = 2;
inline bool FileTableEntry::_internal_has_ownerhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileTableEntry::has_ownerhostname() const {
  return _internal_has_ownerhostname();
}
inline void FileTableEntry::clear_ownerhostname() {
  ownerhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileTableEntry::ownerhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileTableEntry.ownerhostname)
  return _internal_ownerhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTableEntry::set_ownerhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ownerhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.FileTableEntry.ownerhostname)
}
inline std::string* FileTableEntry::mutable_ownerhostname() {
  std::string* _s = _internal_mutable_ownerhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.FileTableEntry.ownerhostname)
  return _s;
}
inline const std::string& FileTableEntry::_internal_ownerhostname() const {
  return ownerhostname_.Get();
}
inline void FileTableEntry::_internal_set_ownerhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ownerhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTableEntry::_internal_mutable_ownerhostname() {
  _has_bits_[0] |= 0x00000001u;
  return ownerhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTableEntry::release_ownerhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.FileTableEntry.ownerhostname)
  if (!_internal_has_ownerhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ownerhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileTableEntry::set_allocated_ownerhostname(std::string* ownerhostname) {
  if (ownerhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ownerhostname_.SetAllocated(ownerhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerhostname_.IsDefault()) {
    ownerhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.FileTableEntry.ownerhostname)
}

// required string ownerport = 3;
inline bool FileTableEntry::_internal_has_ownerport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileTableEntry::has_ownerport() const {
  return _internal_has_ownerport();
}
inline void FileTableEntry::clear_ownerport() {
  ownerport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileTableEntry::ownerport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.FileTableEntry.ownerport)
  return _internal_ownerport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTableEntry::set_ownerport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ownerport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.FileTableEntry.ownerport)
}
inline std::string* FileTableEntry::mutable_ownerport() {
  std::string* _s = _internal_mutable_ownerport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.FileTableEntry.ownerport)
  return _s;
}
inline const std::string& FileTableEntry::_internal_ownerport() const {
  return ownerport_.Get();
}
inline void FileTableEntry::_internal_set_ownerport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ownerport_.Set(value, GetArenaForAllocation());
}
inline std::string* FileTableEntry::_internal_mutable_ownerport() {
  _has_bits_[0] |= 0x00000002u;
  return ownerport_.Mutable(GetArenaForAllocation());
}
inline std::string* FileTableEntry::release_ownerport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.FileTableEntry.ownerport)
  if (!_internal_has_ownerport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ownerport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileTableEntry::set_allocated_ownerport(std::string* ownerport) {
  if (ownerport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ownerport_.SetAllocated(ownerport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ownerport_.IsDefault()) {
    ownerport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.FileTableEntry.ownerport)
}

// -------------------------------------------------------------------

// RouteUpdateRequest

// required string newhostname = 1;
inline bool RouteUpdateRequest::_internal_has_newhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RouteUpdateRequest::has_newhostname() const {
  return _internal_has_newhostname();
}
inline void RouteUpdateRequest::clear_newhostname() {
  newhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouteUpdateRequest::newhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateRequest.newhostname)
  return _internal_newhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteUpdateRequest::set_newhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 newhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateRequest.newhostname)
}
inline std::string* RouteUpdateRequest::mutable_newhostname() {
  std::string* _s = _internal_mutable_newhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteUpdateRequest.newhostname)
  return _s;
}
inline const std::string& RouteUpdateRequest::_internal_newhostname() const {
  return newhostname_.Get();
}
inline void RouteUpdateRequest::_internal_set_newhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  newhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteUpdateRequest::_internal_mutable_newhostname() {
  _has_bits_[0] |= 0x00000001u;
  return newhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteUpdateRequest::release_newhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteUpdateRequest.newhostname)
  if (!_internal_has_newhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = newhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteUpdateRequest::set_allocated_newhostname(std::string* newhostname) {
  if (newhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  newhostname_.SetAllocated(newhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteUpdateRequest.newhostname)
}

// required string newport = 2;
inline bool RouteUpdateRequest::_internal_has_newport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RouteUpdateRequest::has_newport() const {
  return _internal_has_newport();
}
inline void RouteUpdateRequest::clear_newport() {
  newport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RouteUpdateRequest::newport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateRequest.newport)
  return _internal_newport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteUpdateRequest::set_newport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 newport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateRequest.newport)
}
inline std::string* RouteUpdateRequest::mutable_newport() {
  std::string* _s = _internal_mutable_newport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteUpdateRequest.newport)
  return _s;
}
inline const std::string& RouteUpdateRequest::_internal_newport() const {
  return newport_.Get();
}
inline void RouteUpdateRequest::_internal_set_newport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  newport_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteUpdateRequest::_internal_mutable_newport() {
  _has_bits_[0] |= 0x00000002u;
  return newport_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteUpdateRequest::release_newport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteUpdateRequest.newport)
  if (!_internal_has_newport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = newport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteUpdateRequest::set_allocated_newport(std::string* newport) {
  if (newport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  newport_.SetAllocated(newport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteUpdateRequest.newport)
}

// required int64 newhostnamehash = 3;
inline bool RouteUpdateRequest::_internal_has_newhostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RouteUpdateRequest::has_newhostnamehash() const {
  return _internal_has_newhostnamehash();
}
inline void RouteUpdateRequest::clear_newhostnamehash() {
  newhostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t RouteUpdateRequest::_internal_newhostnamehash() const {
  return newhostnamehash_;
}
inline int64_t RouteUpdateRequest::newhostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateRequest.newhostnamehash)
  return _internal_newhostnamehash();
}
inline void RouteUpdateRequest::_internal_set_newhostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  newhostnamehash_ = value;
}
inline void RouteUpdateRequest::set_newhostnamehash(int64_t value) {
  _internal_set_newhostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateRequest.newhostnamehash)
}

// -------------------------------------------------------------------

// RouteUpdateResponse

// required string nextupdatehostname = 1;
inline bool RouteUpdateResponse::_internal_has_nextupdatehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RouteUpdateResponse::has_nextupdatehostname() const {
  return _internal_has_nextupdatehostname();
}
inline void RouteUpdateResponse::clear_nextupdatehostname() {
  nextupdatehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RouteUpdateResponse::nextupdatehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateResponse.nextupdatehostname)
  return _internal_nextupdatehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteUpdateResponse::set_nextupdatehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 nextupdatehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateResponse.nextupdatehostname)
}
inline std::string* RouteUpdateResponse::mutable_nextupdatehostname() {
  std::string* _s = _internal_mutable_nextupdatehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteUpdateResponse.nextupdatehostname)
  return _s;
}
inline const std::string& RouteUpdateResponse::_internal_nextupdatehostname() const {
  return nextupdatehostname_.Get();
}
inline void RouteUpdateResponse::_internal_set_nextupdatehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nextupdatehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteUpdateResponse::_internal_mutable_nextupdatehostname() {
  _has_bits_[0] |= 0x00000001u;
  return nextupdatehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteUpdateResponse::release_nextupdatehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteUpdateResponse.nextupdatehostname)
  if (!_internal_has_nextupdatehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = nextupdatehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nextupdatehostname_.IsDefault()) {
    nextupdatehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteUpdateResponse::set_allocated_nextupdatehostname(std::string* nextupdatehostname) {
  if (nextupdatehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nextupdatehostname_.SetAllocated(nextupdatehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nextupdatehostname_.IsDefault()) {
    nextupdatehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteUpdateResponse.nextupdatehostname)
}

// required string nextupdateport = 2;
inline bool RouteUpdateResponse::_internal_has_nextupdateport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RouteUpdateResponse::has_nextupdateport() const {
  return _internal_has_nextupdateport();
}
inline void RouteUpdateResponse::clear_nextupdateport() {
  nextupdateport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RouteUpdateResponse::nextupdateport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateResponse.nextupdateport)
  return _internal_nextupdateport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteUpdateResponse::set_nextupdateport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 nextupdateport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateResponse.nextupdateport)
}
inline std::string* RouteUpdateResponse::mutable_nextupdateport() {
  std::string* _s = _internal_mutable_nextupdateport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteUpdateResponse.nextupdateport)
  return _s;
}
inline const std::string& RouteUpdateResponse::_internal_nextupdateport() const {
  return nextupdateport_.Get();
}
inline void RouteUpdateResponse::_internal_set_nextupdateport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nextupdateport_.Set(value, GetArenaForAllocation());
}
inline std::string* RouteUpdateResponse::_internal_mutable_nextupdateport() {
  _has_bits_[0] |= 0x00000002u;
  return nextupdateport_.Mutable(GetArenaForAllocation());
}
inline std::string* RouteUpdateResponse::release_nextupdateport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.RouteUpdateResponse.nextupdateport)
  if (!_internal_has_nextupdateport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = nextupdateport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nextupdateport_.IsDefault()) {
    nextupdateport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RouteUpdateResponse::set_allocated_nextupdateport(std::string* nextupdateport) {
  if (nextupdateport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nextupdateport_.SetAllocated(nextupdateport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nextupdateport_.IsDefault()) {
    nextupdateport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.RouteUpdateResponse.nextupdateport)
}

// required int64 nextupdatehostnamehash = 3;
inline bool RouteUpdateResponse::_internal_has_nextupdatehostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RouteUpdateResponse::has_nextupdatehostnamehash() const {
  return _internal_has_nextupdatehostnamehash();
}
inline void RouteUpdateResponse::clear_nextupdatehostnamehash() {
  nextupdatehostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t RouteUpdateResponse::_internal_nextupdatehostnamehash() const {
  return nextupdatehostnamehash_;
}
inline int64_t RouteUpdateResponse::nextupdatehostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateResponse.nextupdatehostnamehash)
  return _internal_nextupdatehostnamehash();
}
inline void RouteUpdateResponse::_internal_set_nextupdatehostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  nextupdatehostnamehash_ = value;
}
inline void RouteUpdateResponse::set_nextupdatehostnamehash(int64_t value) {
  _internal_set_nextupdatehostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateResponse.nextupdatehostnamehash)
}

// required int64 curupdatehostnamehash = 4;
inline bool RouteUpdateResponse::_internal_has_curupdatehostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RouteUpdateResponse::has_curupdatehostnamehash() const {
  return _internal_has_curupdatehostnamehash();
}
inline void RouteUpdateResponse::clear_curupdatehostnamehash() {
  curupdatehostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t RouteUpdateResponse::_internal_curupdatehostnamehash() const {
  return curupdatehostnamehash_;
}
inline int64_t RouteUpdateResponse::curupdatehostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteUpdateResponse.curupdatehostnamehash)
  return _internal_curupdatehostnamehash();
}
inline void RouteUpdateResponse::_internal_set_curupdatehostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  curupdatehostnamehash_ = value;
}
inline void RouteUpdateResponse::set_curupdatehostnamehash(int64_t value) {
  _internal_set_curupdatehostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.RouteUpdateResponse.curupdatehostnamehash)
}

// -------------------------------------------------------------------

// RouteDeleteRequest

// repeated .p2pfilesharing.RouteTableEntry entry = 1;
inline int RouteDeleteRequest::_internal_entry_size() const {
  return entry_.size();
}
inline int RouteDeleteRequest::entry_size() const {
  return _internal_entry_size();
}
inline void RouteDeleteRequest::clear_entry() {
  entry_.Clear();
}
inline ::p2pfilesharing::RouteTableEntry* RouteDeleteRequest::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.RouteDeleteRequest.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >*
RouteDeleteRequest::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:p2pfilesharing.RouteDeleteRequest.entry)
  return &entry_;
}
inline const ::p2pfilesharing::RouteTableEntry& RouteDeleteRequest::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::p2pfilesharing::RouteTableEntry& RouteDeleteRequest::entry(int index) const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.RouteDeleteRequest.entry)
  return _internal_entry(index);
}
inline ::p2pfilesharing::RouteTableEntry* RouteDeleteRequest::_internal_add_entry() {
  return entry_.Add();
}
inline ::p2pfilesharing::RouteTableEntry* RouteDeleteRequest::add_entry() {
  ::p2pfilesharing::RouteTableEntry* _add = _internal_add_entry();
  // @@protoc_insertion_point(field_add:p2pfilesharing.RouteDeleteRequest.entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::p2pfilesharing::RouteTableEntry >&
RouteDeleteRequest::entry() const {
  // @@protoc_insertion_point(field_list:p2pfilesharing.RouteDeleteRequest.entry)
  return entry_;
}

// -------------------------------------------------------------------

// HelpJoinRequset

// required string newhostname = 1;
inline bool HelpJoinRequset::_internal_has_newhostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HelpJoinRequset::has_newhostname() const {
  return _internal_has_newhostname();
}
inline void HelpJoinRequset::clear_newhostname() {
  newhostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HelpJoinRequset::newhostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinRequset.newhostname)
  return _internal_newhostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelpJoinRequset::set_newhostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 newhostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinRequset.newhostname)
}
inline std::string* HelpJoinRequset::mutable_newhostname() {
  std::string* _s = _internal_mutable_newhostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.HelpJoinRequset.newhostname)
  return _s;
}
inline const std::string& HelpJoinRequset::_internal_newhostname() const {
  return newhostname_.Get();
}
inline void HelpJoinRequset::_internal_set_newhostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  newhostname_.Set(value, GetArenaForAllocation());
}
inline std::string* HelpJoinRequset::_internal_mutable_newhostname() {
  _has_bits_[0] |= 0x00000001u;
  return newhostname_.Mutable(GetArenaForAllocation());
}
inline std::string* HelpJoinRequset::release_newhostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.HelpJoinRequset.newhostname)
  if (!_internal_has_newhostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = newhostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HelpJoinRequset::set_allocated_newhostname(std::string* newhostname) {
  if (newhostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  newhostname_.SetAllocated(newhostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newhostname_.IsDefault()) {
    newhostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.HelpJoinRequset.newhostname)
}

// required string newport = 2;
inline bool HelpJoinRequset::_internal_has_newport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HelpJoinRequset::has_newport() const {
  return _internal_has_newport();
}
inline void HelpJoinRequset::clear_newport() {
  newport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HelpJoinRequset::newport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinRequset.newport)
  return _internal_newport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelpJoinRequset::set_newport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 newport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinRequset.newport)
}
inline std::string* HelpJoinRequset::mutable_newport() {
  std::string* _s = _internal_mutable_newport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.HelpJoinRequset.newport)
  return _s;
}
inline const std::string& HelpJoinRequset::_internal_newport() const {
  return newport_.Get();
}
inline void HelpJoinRequset::_internal_set_newport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  newport_.Set(value, GetArenaForAllocation());
}
inline std::string* HelpJoinRequset::_internal_mutable_newport() {
  _has_bits_[0] |= 0x00000002u;
  return newport_.Mutable(GetArenaForAllocation());
}
inline std::string* HelpJoinRequset::release_newport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.HelpJoinRequset.newport)
  if (!_internal_has_newport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = newport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HelpJoinRequset::set_allocated_newport(std::string* newport) {
  if (newport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  newport_.SetAllocated(newport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newport_.IsDefault()) {
    newport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.HelpJoinRequset.newport)
}

// required int64 newhostnamehash = 3;
inline bool HelpJoinRequset::_internal_has_newhostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HelpJoinRequset::has_newhostnamehash() const {
  return _internal_has_newhostnamehash();
}
inline void HelpJoinRequset::clear_newhostnamehash() {
  newhostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t HelpJoinRequset::_internal_newhostnamehash() const {
  return newhostnamehash_;
}
inline int64_t HelpJoinRequset::newhostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinRequset.newhostnamehash)
  return _internal_newhostnamehash();
}
inline void HelpJoinRequset::_internal_set_newhostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  newhostnamehash_ = value;
}
inline void HelpJoinRequset::set_newhostnamehash(int64_t value) {
  _internal_set_newhostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinRequset.newhostnamehash)
}

// -------------------------------------------------------------------

// HelpJoinResponse

// required string responsiblehostname = 1;
inline bool HelpJoinResponse::_internal_has_responsiblehostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HelpJoinResponse::has_responsiblehostname() const {
  return _internal_has_responsiblehostname();
}
inline void HelpJoinResponse::clear_responsiblehostname() {
  responsiblehostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HelpJoinResponse::responsiblehostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinResponse.responsiblehostname)
  return _internal_responsiblehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelpJoinResponse::set_responsiblehostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 responsiblehostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinResponse.responsiblehostname)
}
inline std::string* HelpJoinResponse::mutable_responsiblehostname() {
  std::string* _s = _internal_mutable_responsiblehostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.HelpJoinResponse.responsiblehostname)
  return _s;
}
inline const std::string& HelpJoinResponse::_internal_responsiblehostname() const {
  return responsiblehostname_.Get();
}
inline void HelpJoinResponse::_internal_set_responsiblehostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  responsiblehostname_.Set(value, GetArenaForAllocation());
}
inline std::string* HelpJoinResponse::_internal_mutable_responsiblehostname() {
  _has_bits_[0] |= 0x00000001u;
  return responsiblehostname_.Mutable(GetArenaForAllocation());
}
inline std::string* HelpJoinResponse::release_responsiblehostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.HelpJoinResponse.responsiblehostname)
  if (!_internal_has_responsiblehostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = responsiblehostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (responsiblehostname_.IsDefault()) {
    responsiblehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HelpJoinResponse::set_allocated_responsiblehostname(std::string* responsiblehostname) {
  if (responsiblehostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  responsiblehostname_.SetAllocated(responsiblehostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (responsiblehostname_.IsDefault()) {
    responsiblehostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.HelpJoinResponse.responsiblehostname)
}

// required string responsibleport = 2;
inline bool HelpJoinResponse::_internal_has_responsibleport() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HelpJoinResponse::has_responsibleport() const {
  return _internal_has_responsibleport();
}
inline void HelpJoinResponse::clear_responsibleport() {
  responsibleport_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HelpJoinResponse::responsibleport() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinResponse.responsibleport)
  return _internal_responsibleport();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelpJoinResponse::set_responsibleport(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 responsibleport_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinResponse.responsibleport)
}
inline std::string* HelpJoinResponse::mutable_responsibleport() {
  std::string* _s = _internal_mutable_responsibleport();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.HelpJoinResponse.responsibleport)
  return _s;
}
inline const std::string& HelpJoinResponse::_internal_responsibleport() const {
  return responsibleport_.Get();
}
inline void HelpJoinResponse::_internal_set_responsibleport(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  responsibleport_.Set(value, GetArenaForAllocation());
}
inline std::string* HelpJoinResponse::_internal_mutable_responsibleport() {
  _has_bits_[0] |= 0x00000002u;
  return responsibleport_.Mutable(GetArenaForAllocation());
}
inline std::string* HelpJoinResponse::release_responsibleport() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.HelpJoinResponse.responsibleport)
  if (!_internal_has_responsibleport()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = responsibleport_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (responsibleport_.IsDefault()) {
    responsibleport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HelpJoinResponse::set_allocated_responsibleport(std::string* responsibleport) {
  if (responsibleport != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  responsibleport_.SetAllocated(responsibleport, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (responsibleport_.IsDefault()) {
    responsibleport_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.HelpJoinResponse.responsibleport)
}

// required int64 responhostnamehash = 3;
inline bool HelpJoinResponse::_internal_has_responhostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HelpJoinResponse::has_responhostnamehash() const {
  return _internal_has_responhostnamehash();
}
inline void HelpJoinResponse::clear_responhostnamehash() {
  responhostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t HelpJoinResponse::_internal_responhostnamehash() const {
  return responhostnamehash_;
}
inline int64_t HelpJoinResponse::responhostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.HelpJoinResponse.responhostnamehash)
  return _internal_responhostnamehash();
}
inline void HelpJoinResponse::_internal_set_responhostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  responhostnamehash_ = value;
}
inline void HelpJoinResponse::set_responhostnamehash(int64_t value) {
  _internal_set_responhostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.HelpJoinResponse.responhostnamehash)
}

// -------------------------------------------------------------------

// LookupNodeResponse

// required string hostname = 1;
inline bool LookupNodeResponse::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LookupNodeResponse::has_hostname() const {
  return _internal_has_hostname();
}
inline void LookupNodeResponse::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupNodeResponse::hostname() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupNodeResponse.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupNodeResponse::set_hostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupNodeResponse.hostname)
}
inline std::string* LookupNodeResponse::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupNodeResponse.hostname)
  return _s;
}
inline const std::string& LookupNodeResponse::_internal_hostname() const {
  return hostname_.Get();
}
inline void LookupNodeResponse::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupNodeResponse::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupNodeResponse::release_hostname() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupNodeResponse.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupNodeResponse::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupNodeResponse.hostname)
}

// required string port = 2;
inline bool LookupNodeResponse::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LookupNodeResponse::has_port() const {
  return _internal_has_port();
}
inline void LookupNodeResponse::clear_port() {
  port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LookupNodeResponse::port() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupNodeResponse.port)
  return _internal_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupNodeResponse::set_port(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupNodeResponse.port)
}
inline std::string* LookupNodeResponse::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.LookupNodeResponse.port)
  return _s;
}
inline const std::string& LookupNodeResponse::_internal_port() const {
  return port_.Get();
}
inline void LookupNodeResponse::_internal_set_port(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  port_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupNodeResponse::_internal_mutable_port() {
  _has_bits_[0] |= 0x00000002u;
  return port_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupNodeResponse::release_port() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.LookupNodeResponse.port)
  if (!_internal_has_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = port_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault()) {
    port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LookupNodeResponse::set_allocated_port(std::string* port) {
  if (port != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  port_.SetAllocated(port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_.IsDefault()) {
    port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.LookupNodeResponse.port)
}

// required int64 hostnamehash = 3;
inline bool LookupNodeResponse::_internal_has_hostnamehash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LookupNodeResponse::has_hostnamehash() const {
  return _internal_has_hostnamehash();
}
inline void LookupNodeResponse::clear_hostnamehash() {
  hostnamehash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t LookupNodeResponse::_internal_hostnamehash() const {
  return hostnamehash_;
}
inline int64_t LookupNodeResponse::hostnamehash() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.LookupNodeResponse.hostnamehash)
  return _internal_hostnamehash();
}
inline void LookupNodeResponse::_internal_set_hostnamehash(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  hostnamehash_ = value;
}
inline void LookupNodeResponse::set_hostnamehash(int64_t value) {
  _internal_set_hostnamehash(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.LookupNodeResponse.hostnamehash)
}

// -------------------------------------------------------------------

// NodeRequest

// required int64 type = 1;
inline bool NodeRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NodeRequest::has_type() const {
  return _internal_has_type();
}
inline void NodeRequest::clear_type() {
  type_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline int64_t NodeRequest::_internal_type() const {
  return type_;
}
inline int64_t NodeRequest::type() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.type)
  return _internal_type();
}
inline void NodeRequest::_internal_set_type(int64_t value) {
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void NodeRequest::set_type(int64_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.NodeRequest.type)
}

// optional .p2pfilesharing.AddFileRequest addfile = 2;
inline bool NodeRequest::_internal_has_addfile() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || addfile_ != nullptr);
  return value;
}
inline bool NodeRequest::has_addfile() const {
  return _internal_has_addfile();
}
inline void NodeRequest::clear_addfile() {
  if (addfile_ != nullptr) addfile_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::p2pfilesharing::AddFileRequest& NodeRequest::_internal_addfile() const {
  const ::p2pfilesharing::AddFileRequest* p = addfile_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::AddFileRequest&>(
      ::p2pfilesharing::_AddFileRequest_default_instance_);
}
inline const ::p2pfilesharing::AddFileRequest& NodeRequest::addfile() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.addfile)
  return _internal_addfile();
}
inline void NodeRequest::unsafe_arena_set_allocated_addfile(
    ::p2pfilesharing::AddFileRequest* addfile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addfile_);
  }
  addfile_ = addfile;
  if (addfile) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.addfile)
}
inline ::p2pfilesharing::AddFileRequest* NodeRequest::release_addfile() {
  _has_bits_[0] &= ~0x00000001u;
  ::p2pfilesharing::AddFileRequest* temp = addfile_;
  addfile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::AddFileRequest* NodeRequest::unsafe_arena_release_addfile() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.addfile)
  _has_bits_[0] &= ~0x00000001u;
  ::p2pfilesharing::AddFileRequest* temp = addfile_;
  addfile_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::AddFileRequest* NodeRequest::_internal_mutable_addfile() {
  _has_bits_[0] |= 0x00000001u;
  if (addfile_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::AddFileRequest>(GetArenaForAllocation());
    addfile_ = p;
  }
  return addfile_;
}
inline ::p2pfilesharing::AddFileRequest* NodeRequest::mutable_addfile() {
  ::p2pfilesharing::AddFileRequest* _msg = _internal_mutable_addfile();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.addfile)
  return _msg;
}
inline void NodeRequest::set_allocated_addfile(::p2pfilesharing::AddFileRequest* addfile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addfile_;
  }
  if (addfile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(addfile);
    if (message_arena != submessage_arena) {
      addfile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addfile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addfile_ = addfile;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.addfile)
}

// optional .p2pfilesharing.LookupFileRequest lookup = 3;
inline bool NodeRequest::_internal_has_lookup() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || lookup_ != nullptr);
  return value;
}
inline bool NodeRequest::has_lookup() const {
  return _internal_has_lookup();
}
inline void NodeRequest::clear_lookup() {
  if (lookup_ != nullptr) lookup_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::p2pfilesharing::LookupFileRequest& NodeRequest::_internal_lookup() const {
  const ::p2pfilesharing::LookupFileRequest* p = lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::LookupFileRequest&>(
      ::p2pfilesharing::_LookupFileRequest_default_instance_);
}
inline const ::p2pfilesharing::LookupFileRequest& NodeRequest::lookup() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.lookup)
  return _internal_lookup();
}
inline void NodeRequest::unsafe_arena_set_allocated_lookup(
    ::p2pfilesharing::LookupFileRequest* lookup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookup_);
  }
  lookup_ = lookup;
  if (lookup) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.lookup)
}
inline ::p2pfilesharing::LookupFileRequest* NodeRequest::release_lookup() {
  _has_bits_[0] &= ~0x00000002u;
  ::p2pfilesharing::LookupFileRequest* temp = lookup_;
  lookup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::LookupFileRequest* NodeRequest::unsafe_arena_release_lookup() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.lookup)
  _has_bits_[0] &= ~0x00000002u;
  ::p2pfilesharing::LookupFileRequest* temp = lookup_;
  lookup_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::LookupFileRequest* NodeRequest::_internal_mutable_lookup() {
  _has_bits_[0] |= 0x00000002u;
  if (lookup_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::LookupFileRequest>(GetArenaForAllocation());
    lookup_ = p;
  }
  return lookup_;
}
inline ::p2pfilesharing::LookupFileRequest* NodeRequest::mutable_lookup() {
  ::p2pfilesharing::LookupFileRequest* _msg = _internal_mutable_lookup();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.lookup)
  return _msg;
}
inline void NodeRequest::set_allocated_lookup(::p2pfilesharing::LookupFileRequest* lookup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lookup_;
  }
  if (lookup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lookup);
    if (message_arena != submessage_arena) {
      lookup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lookup_ = lookup;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.lookup)
}

// optional .p2pfilesharing.DeleteFileRequest deletefile = 4;
inline bool NodeRequest::_internal_has_deletefile() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || deletefile_ != nullptr);
  return value;
}
inline bool NodeRequest::has_deletefile() const {
  return _internal_has_deletefile();
}
inline void NodeRequest::clear_deletefile() {
  if (deletefile_ != nullptr) deletefile_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::p2pfilesharing::DeleteFileRequest& NodeRequest::_internal_deletefile() const {
  const ::p2pfilesharing::DeleteFileRequest* p = deletefile_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::DeleteFileRequest&>(
      ::p2pfilesharing::_DeleteFileRequest_default_instance_);
}
inline const ::p2pfilesharing::DeleteFileRequest& NodeRequest::deletefile() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.deletefile)
  return _internal_deletefile();
}
inline void NodeRequest::unsafe_arena_set_allocated_deletefile(
    ::p2pfilesharing::DeleteFileRequest* deletefile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deletefile_);
  }
  deletefile_ = deletefile;
  if (deletefile) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.deletefile)
}
inline ::p2pfilesharing::DeleteFileRequest* NodeRequest::release_deletefile() {
  _has_bits_[0] &= ~0x00000004u;
  ::p2pfilesharing::DeleteFileRequest* temp = deletefile_;
  deletefile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::DeleteFileRequest* NodeRequest::unsafe_arena_release_deletefile() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.deletefile)
  _has_bits_[0] &= ~0x00000004u;
  ::p2pfilesharing::DeleteFileRequest* temp = deletefile_;
  deletefile_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::DeleteFileRequest* NodeRequest::_internal_mutable_deletefile() {
  _has_bits_[0] |= 0x00000004u;
  if (deletefile_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::DeleteFileRequest>(GetArenaForAllocation());
    deletefile_ = p;
  }
  return deletefile_;
}
inline ::p2pfilesharing::DeleteFileRequest* NodeRequest::mutable_deletefile() {
  ::p2pfilesharing::DeleteFileRequest* _msg = _internal_mutable_deletefile();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.deletefile)
  return _msg;
}
inline void NodeRequest::set_allocated_deletefile(::p2pfilesharing::DeleteFileRequest* deletefile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete deletefile_;
  }
  if (deletefile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deletefile);
    if (message_arena != submessage_arena) {
      deletefile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deletefile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  deletefile_ = deletefile;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.deletefile)
}

// optional .p2pfilesharing.DownloadRequest download = 5;
inline bool NodeRequest::_internal_has_download() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || download_ != nullptr);
  return value;
}
inline bool NodeRequest::has_download() const {
  return _internal_has_download();
}
inline void NodeRequest::clear_download() {
  if (download_ != nullptr) download_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::p2pfilesharing::DownloadRequest& NodeRequest::_internal_download() const {
  const ::p2pfilesharing::DownloadRequest* p = download_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::DownloadRequest&>(
      ::p2pfilesharing::_DownloadRequest_default_instance_);
}
inline const ::p2pfilesharing::DownloadRequest& NodeRequest::download() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.download)
  return _internal_download();
}
inline void NodeRequest::unsafe_arena_set_allocated_download(
    ::p2pfilesharing::DownloadRequest* download) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(download_);
  }
  download_ = download;
  if (download) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.download)
}
inline ::p2pfilesharing::DownloadRequest* NodeRequest::release_download() {
  _has_bits_[0] &= ~0x00000008u;
  ::p2pfilesharing::DownloadRequest* temp = download_;
  download_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::DownloadRequest* NodeRequest::unsafe_arena_release_download() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.download)
  _has_bits_[0] &= ~0x00000008u;
  ::p2pfilesharing::DownloadRequest* temp = download_;
  download_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::DownloadRequest* NodeRequest::_internal_mutable_download() {
  _has_bits_[0] |= 0x00000008u;
  if (download_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::DownloadRequest>(GetArenaForAllocation());
    download_ = p;
  }
  return download_;
}
inline ::p2pfilesharing::DownloadRequest* NodeRequest::mutable_download() {
  ::p2pfilesharing::DownloadRequest* _msg = _internal_mutable_download();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.download)
  return _msg;
}
inline void NodeRequest::set_allocated_download(::p2pfilesharing::DownloadRequest* download) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete download_;
  }
  if (download) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(download);
    if (message_arena != submessage_arena) {
      download = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  download_ = download;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.download)
}

// optional .p2pfilesharing.JoinRequest join = 6;
inline bool NodeRequest::_internal_has_join() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || join_ != nullptr);
  return value;
}
inline bool NodeRequest::has_join() const {
  return _internal_has_join();
}
inline void NodeRequest::clear_join() {
  if (join_ != nullptr) join_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::p2pfilesharing::JoinRequest& NodeRequest::_internal_join() const {
  const ::p2pfilesharing::JoinRequest* p = join_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::JoinRequest&>(
      ::p2pfilesharing::_JoinRequest_default_instance_);
}
inline const ::p2pfilesharing::JoinRequest& NodeRequest::join() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.join)
  return _internal_join();
}
inline void NodeRequest::unsafe_arena_set_allocated_join(
    ::p2pfilesharing::JoinRequest* join) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(join_);
  }
  join_ = join;
  if (join) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.join)
}
inline ::p2pfilesharing::JoinRequest* NodeRequest::release_join() {
  _has_bits_[0] &= ~0x00000010u;
  ::p2pfilesharing::JoinRequest* temp = join_;
  join_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::JoinRequest* NodeRequest::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.join)
  _has_bits_[0] &= ~0x00000010u;
  ::p2pfilesharing::JoinRequest* temp = join_;
  join_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::JoinRequest* NodeRequest::_internal_mutable_join() {
  _has_bits_[0] |= 0x00000010u;
  if (join_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::JoinRequest>(GetArenaForAllocation());
    join_ = p;
  }
  return join_;
}
inline ::p2pfilesharing::JoinRequest* NodeRequest::mutable_join() {
  ::p2pfilesharing::JoinRequest* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.join)
  return _msg;
}
inline void NodeRequest::set_allocated_join(::p2pfilesharing::JoinRequest* join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete join_;
  }
  if (join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join);
    if (message_arena != submessage_arena) {
      join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  join_ = join;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.join)
}

// optional .p2pfilesharing.RouteUpdateRequest updateroute = 7;
inline bool NodeRequest::_internal_has_updateroute() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || updateroute_ != nullptr);
  return value;
}
inline bool NodeRequest::has_updateroute() const {
  return _internal_has_updateroute();
}
inline void NodeRequest::clear_updateroute() {
  if (updateroute_ != nullptr) updateroute_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::p2pfilesharing::RouteUpdateRequest& NodeRequest::_internal_updateroute() const {
  const ::p2pfilesharing::RouteUpdateRequest* p = updateroute_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::RouteUpdateRequest&>(
      ::p2pfilesharing::_RouteUpdateRequest_default_instance_);
}
inline const ::p2pfilesharing::RouteUpdateRequest& NodeRequest::updateroute() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.updateroute)
  return _internal_updateroute();
}
inline void NodeRequest::unsafe_arena_set_allocated_updateroute(
    ::p2pfilesharing::RouteUpdateRequest* updateroute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updateroute_);
  }
  updateroute_ = updateroute;
  if (updateroute) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.updateroute)
}
inline ::p2pfilesharing::RouteUpdateRequest* NodeRequest::release_updateroute() {
  _has_bits_[0] &= ~0x00000020u;
  ::p2pfilesharing::RouteUpdateRequest* temp = updateroute_;
  updateroute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::RouteUpdateRequest* NodeRequest::unsafe_arena_release_updateroute() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.updateroute)
  _has_bits_[0] &= ~0x00000020u;
  ::p2pfilesharing::RouteUpdateRequest* temp = updateroute_;
  updateroute_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::RouteUpdateRequest* NodeRequest::_internal_mutable_updateroute() {
  _has_bits_[0] |= 0x00000020u;
  if (updateroute_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::RouteUpdateRequest>(GetArenaForAllocation());
    updateroute_ = p;
  }
  return updateroute_;
}
inline ::p2pfilesharing::RouteUpdateRequest* NodeRequest::mutable_updateroute() {
  ::p2pfilesharing::RouteUpdateRequest* _msg = _internal_mutable_updateroute();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.updateroute)
  return _msg;
}
inline void NodeRequest::set_allocated_updateroute(::p2pfilesharing::RouteUpdateRequest* updateroute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete updateroute_;
  }
  if (updateroute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updateroute);
    if (message_arena != submessage_arena) {
      updateroute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updateroute, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  updateroute_ = updateroute;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.updateroute)
}

// optional .p2pfilesharing.RouteDeleteRequest deleteroute = 8;
inline bool NodeRequest::_internal_has_deleteroute() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || deleteroute_ != nullptr);
  return value;
}
inline bool NodeRequest::has_deleteroute() const {
  return _internal_has_deleteroute();
}
inline void NodeRequest::clear_deleteroute() {
  if (deleteroute_ != nullptr) deleteroute_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::p2pfilesharing::RouteDeleteRequest& NodeRequest::_internal_deleteroute() const {
  const ::p2pfilesharing::RouteDeleteRequest* p = deleteroute_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::RouteDeleteRequest&>(
      ::p2pfilesharing::_RouteDeleteRequest_default_instance_);
}
inline const ::p2pfilesharing::RouteDeleteRequest& NodeRequest::deleteroute() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.deleteroute)
  return _internal_deleteroute();
}
inline void NodeRequest::unsafe_arena_set_allocated_deleteroute(
    ::p2pfilesharing::RouteDeleteRequest* deleteroute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleteroute_);
  }
  deleteroute_ = deleteroute;
  if (deleteroute) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.deleteroute)
}
inline ::p2pfilesharing::RouteDeleteRequest* NodeRequest::release_deleteroute() {
  _has_bits_[0] &= ~0x00000040u;
  ::p2pfilesharing::RouteDeleteRequest* temp = deleteroute_;
  deleteroute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::RouteDeleteRequest* NodeRequest::unsafe_arena_release_deleteroute() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.deleteroute)
  _has_bits_[0] &= ~0x00000040u;
  ::p2pfilesharing::RouteDeleteRequest* temp = deleteroute_;
  deleteroute_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::RouteDeleteRequest* NodeRequest::_internal_mutable_deleteroute() {
  _has_bits_[0] |= 0x00000040u;
  if (deleteroute_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::RouteDeleteRequest>(GetArenaForAllocation());
    deleteroute_ = p;
  }
  return deleteroute_;
}
inline ::p2pfilesharing::RouteDeleteRequest* NodeRequest::mutable_deleteroute() {
  ::p2pfilesharing::RouteDeleteRequest* _msg = _internal_mutable_deleteroute();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.deleteroute)
  return _msg;
}
inline void NodeRequest::set_allocated_deleteroute(::p2pfilesharing::RouteDeleteRequest* deleteroute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete deleteroute_;
  }
  if (deleteroute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deleteroute);
    if (message_arena != submessage_arena) {
      deleteroute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleteroute, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  deleteroute_ = deleteroute;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.deleteroute)
}

// optional .p2pfilesharing.HelpJoinRequset helpjoin = 9;
inline bool NodeRequest::_internal_has_helpjoin() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || helpjoin_ != nullptr);
  return value;
}
inline bool NodeRequest::has_helpjoin() const {
  return _internal_has_helpjoin();
}
inline void NodeRequest::clear_helpjoin() {
  if (helpjoin_ != nullptr) helpjoin_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::p2pfilesharing::HelpJoinRequset& NodeRequest::_internal_helpjoin() const {
  const ::p2pfilesharing::HelpJoinRequset* p = helpjoin_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::HelpJoinRequset&>(
      ::p2pfilesharing::_HelpJoinRequset_default_instance_);
}
inline const ::p2pfilesharing::HelpJoinRequset& NodeRequest::helpjoin() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeRequest.helpjoin)
  return _internal_helpjoin();
}
inline void NodeRequest::unsafe_arena_set_allocated_helpjoin(
    ::p2pfilesharing::HelpJoinRequset* helpjoin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(helpjoin_);
  }
  helpjoin_ = helpjoin;
  if (helpjoin) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeRequest.helpjoin)
}
inline ::p2pfilesharing::HelpJoinRequset* NodeRequest::release_helpjoin() {
  _has_bits_[0] &= ~0x00000080u;
  ::p2pfilesharing::HelpJoinRequset* temp = helpjoin_;
  helpjoin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::HelpJoinRequset* NodeRequest::unsafe_arena_release_helpjoin() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeRequest.helpjoin)
  _has_bits_[0] &= ~0x00000080u;
  ::p2pfilesharing::HelpJoinRequset* temp = helpjoin_;
  helpjoin_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::HelpJoinRequset* NodeRequest::_internal_mutable_helpjoin() {
  _has_bits_[0] |= 0x00000080u;
  if (helpjoin_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::HelpJoinRequset>(GetArenaForAllocation());
    helpjoin_ = p;
  }
  return helpjoin_;
}
inline ::p2pfilesharing::HelpJoinRequset* NodeRequest::mutable_helpjoin() {
  ::p2pfilesharing::HelpJoinRequset* _msg = _internal_mutable_helpjoin();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeRequest.helpjoin)
  return _msg;
}
inline void NodeRequest::set_allocated_helpjoin(::p2pfilesharing::HelpJoinRequset* helpjoin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete helpjoin_;
  }
  if (helpjoin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helpjoin);
    if (message_arena != submessage_arena) {
      helpjoin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helpjoin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  helpjoin_ = helpjoin;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeRequest.helpjoin)
}

// -------------------------------------------------------------------

// NodeResponse

// required int64 type = 1;
inline bool NodeResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NodeResponse::has_type() const {
  return _internal_has_type();
}
inline void NodeResponse::clear_type() {
  type_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline int64_t NodeResponse::_internal_type() const {
  return type_;
}
inline int64_t NodeResponse::type() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.type)
  return _internal_type();
}
inline void NodeResponse::_internal_set_type(int64_t value) {
  _has_bits_[0] |= 0x00000080u;
  type_ = value;
}
inline void NodeResponse::set_type(int64_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:p2pfilesharing.NodeResponse.type)
}

// optional .p2pfilesharing.LookupFileResponse lookup = 2;
inline bool NodeResponse::_internal_has_lookup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || lookup_ != nullptr);
  return value;
}
inline bool NodeResponse::has_lookup() const {
  return _internal_has_lookup();
}
inline void NodeResponse::clear_lookup() {
  if (lookup_ != nullptr) lookup_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::p2pfilesharing::LookupFileResponse& NodeResponse::_internal_lookup() const {
  const ::p2pfilesharing::LookupFileResponse* p = lookup_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::LookupFileResponse&>(
      ::p2pfilesharing::_LookupFileResponse_default_instance_);
}
inline const ::p2pfilesharing::LookupFileResponse& NodeResponse::lookup() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.lookup)
  return _internal_lookup();
}
inline void NodeResponse::unsafe_arena_set_allocated_lookup(
    ::p2pfilesharing::LookupFileResponse* lookup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookup_);
  }
  lookup_ = lookup;
  if (lookup) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.lookup)
}
inline ::p2pfilesharing::LookupFileResponse* NodeResponse::release_lookup() {
  _has_bits_[0] &= ~0x00000001u;
  ::p2pfilesharing::LookupFileResponse* temp = lookup_;
  lookup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::LookupFileResponse* NodeResponse::unsafe_arena_release_lookup() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.lookup)
  _has_bits_[0] &= ~0x00000001u;
  ::p2pfilesharing::LookupFileResponse* temp = lookup_;
  lookup_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::LookupFileResponse* NodeResponse::_internal_mutable_lookup() {
  _has_bits_[0] |= 0x00000001u;
  if (lookup_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::LookupFileResponse>(GetArenaForAllocation());
    lookup_ = p;
  }
  return lookup_;
}
inline ::p2pfilesharing::LookupFileResponse* NodeResponse::mutable_lookup() {
  ::p2pfilesharing::LookupFileResponse* _msg = _internal_mutable_lookup();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.lookup)
  return _msg;
}
inline void NodeResponse::set_allocated_lookup(::p2pfilesharing::LookupFileResponse* lookup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lookup_;
  }
  if (lookup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lookup);
    if (message_arena != submessage_arena) {
      lookup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lookup_ = lookup;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.lookup)
}

// optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
inline bool NodeResponse::_internal_has_fileinforsp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || fileinforsp_ != nullptr);
  return value;
}
inline bool NodeResponse::has_fileinforsp() const {
  return _internal_has_fileinforsp();
}
inline void NodeResponse::clear_fileinforsp() {
  if (fileinforsp_ != nullptr) fileinforsp_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::p2pfilesharing::FileInfoResponse& NodeResponse::_internal_fileinforsp() const {
  const ::p2pfilesharing::FileInfoResponse* p = fileinforsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::FileInfoResponse&>(
      ::p2pfilesharing::_FileInfoResponse_default_instance_);
}
inline const ::p2pfilesharing::FileInfoResponse& NodeResponse::fileinforsp() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.fileinforsp)
  return _internal_fileinforsp();
}
inline void NodeResponse::unsafe_arena_set_allocated_fileinforsp(
    ::p2pfilesharing::FileInfoResponse* fileinforsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fileinforsp_);
  }
  fileinforsp_ = fileinforsp;
  if (fileinforsp) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.fileinforsp)
}
inline ::p2pfilesharing::FileInfoResponse* NodeResponse::release_fileinforsp() {
  _has_bits_[0] &= ~0x00000002u;
  ::p2pfilesharing::FileInfoResponse* temp = fileinforsp_;
  fileinforsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::FileInfoResponse* NodeResponse::unsafe_arena_release_fileinforsp() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.fileinforsp)
  _has_bits_[0] &= ~0x00000002u;
  ::p2pfilesharing::FileInfoResponse* temp = fileinforsp_;
  fileinforsp_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::FileInfoResponse* NodeResponse::_internal_mutable_fileinforsp() {
  _has_bits_[0] |= 0x00000002u;
  if (fileinforsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::FileInfoResponse>(GetArenaForAllocation());
    fileinforsp_ = p;
  }
  return fileinforsp_;
}
inline ::p2pfilesharing::FileInfoResponse* NodeResponse::mutable_fileinforsp() {
  ::p2pfilesharing::FileInfoResponse* _msg = _internal_mutable_fileinforsp();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.fileinforsp)
  return _msg;
}
inline void NodeResponse::set_allocated_fileinforsp(::p2pfilesharing::FileInfoResponse* fileinforsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fileinforsp_;
  }
  if (fileinforsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fileinforsp);
    if (message_arena != submessage_arena) {
      fileinforsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinforsp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fileinforsp_ = fileinforsp;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.fileinforsp)
}

// optional .p2pfilesharing.RouteTableInit routeinit = 4;
inline bool NodeResponse::_internal_has_routeinit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || routeinit_ != nullptr);
  return value;
}
inline bool NodeResponse::has_routeinit() const {
  return _internal_has_routeinit();
}
inline void NodeResponse::clear_routeinit() {
  if (routeinit_ != nullptr) routeinit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::p2pfilesharing::RouteTableInit& NodeResponse::_internal_routeinit() const {
  const ::p2pfilesharing::RouteTableInit* p = routeinit_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::RouteTableInit&>(
      ::p2pfilesharing::_RouteTableInit_default_instance_);
}
inline const ::p2pfilesharing::RouteTableInit& NodeResponse::routeinit() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.routeinit)
  return _internal_routeinit();
}
inline void NodeResponse::unsafe_arena_set_allocated_routeinit(
    ::p2pfilesharing::RouteTableInit* routeinit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routeinit_);
  }
  routeinit_ = routeinit;
  if (routeinit) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.routeinit)
}
inline ::p2pfilesharing::RouteTableInit* NodeResponse::release_routeinit() {
  _has_bits_[0] &= ~0x00000004u;
  ::p2pfilesharing::RouteTableInit* temp = routeinit_;
  routeinit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::RouteTableInit* NodeResponse::unsafe_arena_release_routeinit() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.routeinit)
  _has_bits_[0] &= ~0x00000004u;
  ::p2pfilesharing::RouteTableInit* temp = routeinit_;
  routeinit_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::RouteTableInit* NodeResponse::_internal_mutable_routeinit() {
  _has_bits_[0] |= 0x00000004u;
  if (routeinit_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::RouteTableInit>(GetArenaForAllocation());
    routeinit_ = p;
  }
  return routeinit_;
}
inline ::p2pfilesharing::RouteTableInit* NodeResponse::mutable_routeinit() {
  ::p2pfilesharing::RouteTableInit* _msg = _internal_mutable_routeinit();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.routeinit)
  return _msg;
}
inline void NodeResponse::set_allocated_routeinit(::p2pfilesharing::RouteTableInit* routeinit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routeinit_;
  }
  if (routeinit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routeinit);
    if (message_arena != submessage_arena) {
      routeinit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routeinit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  routeinit_ = routeinit;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.routeinit)
}

// optional .p2pfilesharing.FileTable filetable = 5;
inline bool NodeResponse::_internal_has_filetable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || filetable_ != nullptr);
  return value;
}
inline bool NodeResponse::has_filetable() const {
  return _internal_has_filetable();
}
inline void NodeResponse::clear_filetable() {
  if (filetable_ != nullptr) filetable_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::p2pfilesharing::FileTable& NodeResponse::_internal_filetable() const {
  const ::p2pfilesharing::FileTable* p = filetable_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::FileTable&>(
      ::p2pfilesharing::_FileTable_default_instance_);
}
inline const ::p2pfilesharing::FileTable& NodeResponse::filetable() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.filetable)
  return _internal_filetable();
}
inline void NodeResponse::unsafe_arena_set_allocated_filetable(
    ::p2pfilesharing::FileTable* filetable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filetable_);
  }
  filetable_ = filetable;
  if (filetable) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.filetable)
}
inline ::p2pfilesharing::FileTable* NodeResponse::release_filetable() {
  _has_bits_[0] &= ~0x00000008u;
  ::p2pfilesharing::FileTable* temp = filetable_;
  filetable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::FileTable* NodeResponse::unsafe_arena_release_filetable() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.filetable)
  _has_bits_[0] &= ~0x00000008u;
  ::p2pfilesharing::FileTable* temp = filetable_;
  filetable_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::FileTable* NodeResponse::_internal_mutable_filetable() {
  _has_bits_[0] |= 0x00000008u;
  if (filetable_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::FileTable>(GetArenaForAllocation());
    filetable_ = p;
  }
  return filetable_;
}
inline ::p2pfilesharing::FileTable* NodeResponse::mutable_filetable() {
  ::p2pfilesharing::FileTable* _msg = _internal_mutable_filetable();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.filetable)
  return _msg;
}
inline void NodeResponse::set_allocated_filetable(::p2pfilesharing::FileTable* filetable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filetable_;
  }
  if (filetable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filetable);
    if (message_arena != submessage_arena) {
      filetable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filetable, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  filetable_ = filetable;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.filetable)
}

// optional .p2pfilesharing.HelpJoinResponse helpjoin = 6;
inline bool NodeResponse::_internal_has_helpjoin() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || helpjoin_ != nullptr);
  return value;
}
inline bool NodeResponse::has_helpjoin() const {
  return _internal_has_helpjoin();
}
inline void NodeResponse::clear_helpjoin() {
  if (helpjoin_ != nullptr) helpjoin_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::p2pfilesharing::HelpJoinResponse& NodeResponse::_internal_helpjoin() const {
  const ::p2pfilesharing::HelpJoinResponse* p = helpjoin_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::HelpJoinResponse&>(
      ::p2pfilesharing::_HelpJoinResponse_default_instance_);
}
inline const ::p2pfilesharing::HelpJoinResponse& NodeResponse::helpjoin() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.helpjoin)
  return _internal_helpjoin();
}
inline void NodeResponse::unsafe_arena_set_allocated_helpjoin(
    ::p2pfilesharing::HelpJoinResponse* helpjoin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(helpjoin_);
  }
  helpjoin_ = helpjoin;
  if (helpjoin) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.helpjoin)
}
inline ::p2pfilesharing::HelpJoinResponse* NodeResponse::release_helpjoin() {
  _has_bits_[0] &= ~0x00000010u;
  ::p2pfilesharing::HelpJoinResponse* temp = helpjoin_;
  helpjoin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::HelpJoinResponse* NodeResponse::unsafe_arena_release_helpjoin() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.helpjoin)
  _has_bits_[0] &= ~0x00000010u;
  ::p2pfilesharing::HelpJoinResponse* temp = helpjoin_;
  helpjoin_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::HelpJoinResponse* NodeResponse::_internal_mutable_helpjoin() {
  _has_bits_[0] |= 0x00000010u;
  if (helpjoin_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::HelpJoinResponse>(GetArenaForAllocation());
    helpjoin_ = p;
  }
  return helpjoin_;
}
inline ::p2pfilesharing::HelpJoinResponse* NodeResponse::mutable_helpjoin() {
  ::p2pfilesharing::HelpJoinResponse* _msg = _internal_mutable_helpjoin();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.helpjoin)
  return _msg;
}
inline void NodeResponse::set_allocated_helpjoin(::p2pfilesharing::HelpJoinResponse* helpjoin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete helpjoin_;
  }
  if (helpjoin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helpjoin);
    if (message_arena != submessage_arena) {
      helpjoin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helpjoin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  helpjoin_ = helpjoin;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.helpjoin)
}

// optional .p2pfilesharing.RouteUpdateResponse updateroute = 7;
inline bool NodeResponse::_internal_has_updateroute() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || updateroute_ != nullptr);
  return value;
}
inline bool NodeResponse::has_updateroute() const {
  return _internal_has_updateroute();
}
inline void NodeResponse::clear_updateroute() {
  if (updateroute_ != nullptr) updateroute_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::p2pfilesharing::RouteUpdateResponse& NodeResponse::_internal_updateroute() const {
  const ::p2pfilesharing::RouteUpdateResponse* p = updateroute_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::RouteUpdateResponse&>(
      ::p2pfilesharing::_RouteUpdateResponse_default_instance_);
}
inline const ::p2pfilesharing::RouteUpdateResponse& NodeResponse::updateroute() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.updateroute)
  return _internal_updateroute();
}
inline void NodeResponse::unsafe_arena_set_allocated_updateroute(
    ::p2pfilesharing::RouteUpdateResponse* updateroute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updateroute_);
  }
  updateroute_ = updateroute;
  if (updateroute) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.updateroute)
}
inline ::p2pfilesharing::RouteUpdateResponse* NodeResponse::release_updateroute() {
  _has_bits_[0] &= ~0x00000020u;
  ::p2pfilesharing::RouteUpdateResponse* temp = updateroute_;
  updateroute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::RouteUpdateResponse* NodeResponse::unsafe_arena_release_updateroute() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.updateroute)
  _has_bits_[0] &= ~0x00000020u;
  ::p2pfilesharing::RouteUpdateResponse* temp = updateroute_;
  updateroute_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::RouteUpdateResponse* NodeResponse::_internal_mutable_updateroute() {
  _has_bits_[0] |= 0x00000020u;
  if (updateroute_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::RouteUpdateResponse>(GetArenaForAllocation());
    updateroute_ = p;
  }
  return updateroute_;
}
inline ::p2pfilesharing::RouteUpdateResponse* NodeResponse::mutable_updateroute() {
  ::p2pfilesharing::RouteUpdateResponse* _msg = _internal_mutable_updateroute();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.updateroute)
  return _msg;
}
inline void NodeResponse::set_allocated_updateroute(::p2pfilesharing::RouteUpdateResponse* updateroute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete updateroute_;
  }
  if (updateroute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updateroute);
    if (message_arena != submessage_arena) {
      updateroute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updateroute, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  updateroute_ = updateroute;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.updateroute)
}

// optional .p2pfilesharing.LookupNodeResponse lookupnode = 8;
inline bool NodeResponse::_internal_has_lookupnode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || lookupnode_ != nullptr);
  return value;
}
inline bool NodeResponse::has_lookupnode() const {
  return _internal_has_lookupnode();
}
inline void NodeResponse::clear_lookupnode() {
  if (lookupnode_ != nullptr) lookupnode_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::p2pfilesharing::LookupNodeResponse& NodeResponse::_internal_lookupnode() const {
  const ::p2pfilesharing::LookupNodeResponse* p = lookupnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::p2pfilesharing::LookupNodeResponse&>(
      ::p2pfilesharing::_LookupNodeResponse_default_instance_);
}
inline const ::p2pfilesharing::LookupNodeResponse& NodeResponse::lookupnode() const {
  // @@protoc_insertion_point(field_get:p2pfilesharing.NodeResponse.lookupnode)
  return _internal_lookupnode();
}
inline void NodeResponse::unsafe_arena_set_allocated_lookupnode(
    ::p2pfilesharing::LookupNodeResponse* lookupnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookupnode_);
  }
  lookupnode_ = lookupnode;
  if (lookupnode) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:p2pfilesharing.NodeResponse.lookupnode)
}
inline ::p2pfilesharing::LookupNodeResponse* NodeResponse::release_lookupnode() {
  _has_bits_[0] &= ~0x00000040u;
  ::p2pfilesharing::LookupNodeResponse* temp = lookupnode_;
  lookupnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::p2pfilesharing::LookupNodeResponse* NodeResponse::unsafe_arena_release_lookupnode() {
  // @@protoc_insertion_point(field_release:p2pfilesharing.NodeResponse.lookupnode)
  _has_bits_[0] &= ~0x00000040u;
  ::p2pfilesharing::LookupNodeResponse* temp = lookupnode_;
  lookupnode_ = nullptr;
  return temp;
}
inline ::p2pfilesharing::LookupNodeResponse* NodeResponse::_internal_mutable_lookupnode() {
  _has_bits_[0] |= 0x00000040u;
  if (lookupnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::p2pfilesharing::LookupNodeResponse>(GetArenaForAllocation());
    lookupnode_ = p;
  }
  return lookupnode_;
}
inline ::p2pfilesharing::LookupNodeResponse* NodeResponse::mutable_lookupnode() {
  ::p2pfilesharing::LookupNodeResponse* _msg = _internal_mutable_lookupnode();
  // @@protoc_insertion_point(field_mutable:p2pfilesharing.NodeResponse.lookupnode)
  return _msg;
}
inline void NodeResponse::set_allocated_lookupnode(::p2pfilesharing::LookupNodeResponse* lookupnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lookupnode_;
  }
  if (lookupnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lookupnode);
    if (message_arena != submessage_arena) {
      lookupnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookupnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  lookupnode_ = lookupnode;
  // @@protoc_insertion_point(field_set_allocated:p2pfilesharing.NodeResponse.lookupnode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace p2pfilesharing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_P2P_5fProtocol_2eproto
