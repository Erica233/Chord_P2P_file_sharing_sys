// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2P_Protocol.proto

#include "P2P_Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace p2pfilesharing {
PROTOBUF_CONSTEXPR AddFileRequest::AddFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct AddFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFileRequestDefaultTypeInternal() {}
  union {
    AddFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFileRequestDefaultTypeInternal _AddFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileRequest::LookupFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct LookupFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileRequestDefaultTypeInternal() {}
  union {
    LookupFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileRequestDefaultTypeInternal _LookupFileRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteFileRequest::DeleteFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct DeleteFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteFileRequestDefaultTypeInternal() {}
  union {
    DeleteFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileResponse::LookupFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ownerhostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ownerport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ifexists_)*/false} {}
struct LookupFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileResponseDefaultTypeInternal() {}
  union {
    LookupFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileResponseDefaultTypeInternal _LookupFileResponse_default_instance_;
PROTOBUF_CONSTEXPR fileInfoRequest::fileInfoRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct fileInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR fileInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~fileInfoRequestDefaultTypeInternal() {}
  union {
    fileInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 fileInfoRequestDefaultTypeInternal _fileInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR fileInfoResponse::fileInfoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ownerhostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ownerport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct fileInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR fileInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~fileInfoResponseDefaultTypeInternal() {}
  union {
    fileInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 fileInfoResponseDefaultTypeInternal _fileInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR downloadRequest::downloadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct downloadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR downloadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~downloadRequestDefaultTypeInternal() {}
  union {
    downloadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 downloadRequestDefaultTypeInternal _downloadRequest_default_instance_;
PROTOBUF_CONSTEXPR joinRequest::joinRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcehostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostnamehash_)*/int64_t{0}} {}
struct joinRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR joinRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~joinRequestDefaultTypeInternal() {}
  union {
    joinRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 joinRequestDefaultTypeInternal _joinRequest_default_instance_;
PROTOBUF_CONSTEXPR routeTableInit::routeTableInit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entry_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct routeTableInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR routeTableInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~routeTableInitDefaultTypeInternal() {}
  union {
    routeTableInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 routeTableInitDefaultTypeInternal _routeTableInit_default_instance_;
PROTOBUF_CONSTEXPR routeTableEntry::routeTableEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostnamehash_)*/int64_t{0}} {}
struct routeTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR routeTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~routeTableEntryDefaultTypeInternal() {}
  union {
    routeTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 routeTableEntryDefaultTypeInternal _routeTableEntry_default_instance_;
PROTOBUF_CONSTEXPR fileTable::fileTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entry_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct fileTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR fileTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~fileTableDefaultTypeInternal() {}
  union {
    fileTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 fileTableDefaultTypeInternal _fileTable_default_instance_;
PROTOBUF_CONSTEXPR fileTableEntry::fileTableEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ownerhostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ownerport_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filenamehash_)*/int64_t{0}} {}
struct fileTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR fileTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~fileTableEntryDefaultTypeInternal() {}
  union {
    fileTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 fileTableEntryDefaultTypeInternal _fileTableEntry_default_instance_;
PROTOBUF_CONSTEXPR routeInsertRequest::routeInsertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entry_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct routeInsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR routeInsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~routeInsertRequestDefaultTypeInternal() {}
  union {
    routeInsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 routeInsertRequestDefaultTypeInternal _routeInsertRequest_default_instance_;
PROTOBUF_CONSTEXPR routeDeleteRequest::routeDeleteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entry_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct routeDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR routeDeleteRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~routeDeleteRequestDefaultTypeInternal() {}
  union {
    routeDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 routeDeleteRequestDefaultTypeInternal _routeDeleteRequest_default_instance_;
}  // namespace p2pfilesharing
static ::_pb::Metadata file_level_metadata_P2P_5fProtocol_2eproto[14];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_P2P_5fProtocol_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_P2P_5fProtocol_2eproto = nullptr;

const uint32_t TableStruct_P2P_5fProtocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _impl_.sourcehostname_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _impl_.sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _impl_.sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _impl_.sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _impl_.sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _impl_.ifexists_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _impl_.ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _impl_.ownerport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoRequest, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoRequest, _impl_.sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoRequest, _impl_.sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoResponse, _impl_.ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileInfoResponse, _impl_.ownerport_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::downloadRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::downloadRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::downloadRequest, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::downloadRequest, _impl_.sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::downloadRequest, _impl_.sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::joinRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::joinRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::joinRequest, _impl_.sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::joinRequest, _impl_.sourceport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::joinRequest, _impl_.hostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableInit, _impl_.entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableEntry, _impl_.hostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableEntry, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeTableEntry, _impl_.hostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTable, _impl_.entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTableEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTableEntry, _impl_.filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTableEntry, _impl_.ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::fileTableEntry, _impl_.ownerport_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeInsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeInsertRequest, _impl_.entry_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::routeDeleteRequest, _impl_.entry_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::p2pfilesharing::AddFileRequest)},
  { 10, 19, -1, sizeof(::p2pfilesharing::LookupFileRequest)},
  { 22, 31, -1, sizeof(::p2pfilesharing::DeleteFileRequest)},
  { 34, 43, -1, sizeof(::p2pfilesharing::LookupFileResponse)},
  { 46, 55, -1, sizeof(::p2pfilesharing::fileInfoRequest)},
  { 58, 66, -1, sizeof(::p2pfilesharing::fileInfoResponse)},
  { 68, 77, -1, sizeof(::p2pfilesharing::downloadRequest)},
  { 80, 89, -1, sizeof(::p2pfilesharing::joinRequest)},
  { 92, -1, -1, sizeof(::p2pfilesharing::routeTableInit)},
  { 99, 108, -1, sizeof(::p2pfilesharing::routeTableEntry)},
  { 111, -1, -1, sizeof(::p2pfilesharing::fileTable)},
  { 118, 127, -1, sizeof(::p2pfilesharing::fileTableEntry)},
  { 130, -1, -1, sizeof(::p2pfilesharing::routeInsertRequest)},
  { 137, -1, -1, sizeof(::p2pfilesharing::routeDeleteRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::p2pfilesharing::_AddFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileRequest_default_instance_._instance,
  &::p2pfilesharing::_DeleteFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileResponse_default_instance_._instance,
  &::p2pfilesharing::_fileInfoRequest_default_instance_._instance,
  &::p2pfilesharing::_fileInfoResponse_default_instance_._instance,
  &::p2pfilesharing::_downloadRequest_default_instance_._instance,
  &::p2pfilesharing::_joinRequest_default_instance_._instance,
  &::p2pfilesharing::_routeTableInit_default_instance_._instance,
  &::p2pfilesharing::_routeTableEntry_default_instance_._instance,
  &::p2pfilesharing::_fileTable_default_instance_._instance,
  &::p2pfilesharing::_fileTableEntry_default_instance_._instance,
  &::p2pfilesharing::_routeInsertRequest_default_instance_._instance,
  &::p2pfilesharing::_routeDeleteRequest_default_instance_._instance,
};

const char descriptor_table_protodef_P2P_5fProtocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022P2P_Protocol.proto\022\016p2pfilesharing\">\n\016"
  "AddFileRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016"
  "sourcehostname\030\002 \002(\t\"U\n\021LookupFileReques"
  "t\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016sourcehostnam"
  "e\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"U\n\021DeleteFil"
  "eRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016source"
  "hostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"P\n\022Lo"
  "okupFileResponse\022\020\n\010ifexists\030\001 \002(\010\022\025\n\row"
  "nerhostname\030\002 \001(\t\022\021\n\townerport\030\003 \001(\t\"S\n\017"
  "fileInfoRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n"
  "\016sourcehostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002("
  "\t\"<\n\020fileInfoResponse\022\025\n\rownerhostname\030\001"
  " \002(\t\022\021\n\townerport\030\002 \002(\t\"S\n\017downloadReque"
  "st\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016sourcehostna"
  "me\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"O\n\013joinRequ"
  "est\022\026\n\016sourcehostname\030\001 \002(\t\022\022\n\nsourcepor"
  "t\030\002 \002(\t\022\024\n\014hostnamehash\030\003 \002(\003\"@\n\016routeTa"
  "bleInit\022.\n\005entry\030\001 \003(\0132\037.p2pfilesharing."
  "routeTableEntry\"G\n\017routeTableEntry\022\020\n\010ho"
  "stname\030\001 \002(\t\022\014\n\004port\030\002 \002(\t\022\024\n\014hostnameha"
  "sh\030\003 \002(\003\":\n\tfileTable\022-\n\005entry\030\001 \003(\0132\036.p"
  "2pfilesharing.fileTableEntry\"P\n\016fileTabl"
  "eEntry\022\024\n\014filenamehash\030\001 \002(\003\022\025\n\rownerhos"
  "tname\030\002 \002(\t\022\021\n\townerport\030\003 \002(\t\"D\n\022routeI"
  "nsertRequest\022.\n\005entry\030\001 \003(\0132\037.p2pfilesha"
  "ring.routeTableEntry\"D\n\022routeDeleteReque"
  "st\022.\n\005entry\030\001 \003(\0132\037.p2pfilesharing.route"
  "TableEntry"
  ;
static ::_pbi::once_flag descriptor_table_P2P_5fProtocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_P2P_5fProtocol_2eproto = {
    false, false, 1090, descriptor_table_protodef_P2P_5fProtocol_2eproto,
    "P2P_Protocol.proto",
    &descriptor_table_P2P_5fProtocol_2eproto_once, nullptr, 0, 14,
    schemas, file_default_instances, TableStruct_P2P_5fProtocol_2eproto::offsets,
    file_level_metadata_P2P_5fProtocol_2eproto, file_level_enum_descriptors_P2P_5fProtocol_2eproto,
    file_level_service_descriptors_P2P_5fProtocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_P2P_5fProtocol_2eproto_getter() {
  return &descriptor_table_P2P_5fProtocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_P2P_5fProtocol_2eproto(&descriptor_table_P2P_5fProtocol_2eproto);
namespace p2pfilesharing {

// ===================================================================

class AddFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFileRequest>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AddFileRequest::AddFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.AddFileRequest)
}
AddFileRequest::AddFileRequest(const AddFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.AddFileRequest)
}

inline void AddFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddFileRequest::~AddFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.AddFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
}

void AddFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.sourcehostname_.ClearNonDefaultToEmpty();
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.AddFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.AddFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.AddFileRequest)
  return target;
}

size_t AddFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t AddFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFileRequest::GetClassData() const { return &_class_data_; }


void AddFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddFileRequest*>(&to_msg);
  auto& from = static_cast<const AddFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.AddFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFileRequest::CopyFrom(const AddFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.AddFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AddFileRequest::InternalSwap(AddFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[0]);
}

// ===================================================================

class LookupFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileRequest>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LookupFileRequest::LookupFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileRequest)
}
LookupFileRequest::LookupFileRequest(const LookupFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LookupFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    _this->_impl_.sourceport_.Set(from._internal_sourceport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileRequest)
}

inline void LookupFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LookupFileRequest::~LookupFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
  _impl_.sourceport_.Destroy();
}

void LookupFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LookupFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileRequest)
  return target;
}

size_t LookupFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t LookupFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LookupFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileRequest::GetClassData() const { return &_class_data_; }


void LookupFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LookupFileRequest*>(&to_msg);
  auto& from = static_cast<const LookupFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileRequest::CopyFrom(const LookupFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LookupFileRequest::InternalSwap(LookupFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceport_, lhs_arena,
      &other->_impl_.sourceport_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[1]);
}

// ===================================================================

class DeleteFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteFileRequest>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DeleteFileRequest::DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.DeleteFileRequest)
}
DeleteFileRequest::DeleteFileRequest(const DeleteFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    _this->_impl_.sourceport_.Set(from._internal_sourceport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.DeleteFileRequest)
}

inline void DeleteFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteFileRequest::~DeleteFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.DeleteFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
  _impl_.sourceport_.Destroy();
}

void DeleteFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.DeleteFileRequest)
  return target;
}

size_t DeleteFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t DeleteFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteFileRequest::GetClassData() const { return &_class_data_; }


void DeleteFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteFileRequest*>(&to_msg);
  auto& from = static_cast<const DeleteFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.DeleteFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteFileRequest::CopyFrom(const DeleteFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.DeleteFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DeleteFileRequest::InternalSwap(DeleteFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceport_, lhs_arena,
      &other->_impl_.sourceport_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[2]);
}

// ===================================================================

class LookupFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileResponse>()._impl_._has_bits_);
  static void set_has_ifexists(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

LookupFileResponse::LookupFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileResponse)
}
LookupFileResponse::LookupFileResponse(const LookupFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LookupFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}
    , decltype(_impl_.ifexists_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    _this->_impl_.ownerhostname_.Set(from._internal_ownerhostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    _this->_impl_.ownerport_.Set(from._internal_ownerport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.ifexists_ = from._impl_.ifexists_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileResponse)
}

inline void LookupFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}
    , decltype(_impl_.ifexists_){false}
  };
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LookupFileResponse::~LookupFileResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ownerhostname_.Destroy();
  _impl_.ownerport_.Destroy();
}

void LookupFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LookupFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ownerport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.ifexists_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool ifexists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ifexists(&has_bits);
          _impl_.ifexists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ownerhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ownerport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool ifexists = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifexists(), target);
  }

  // optional string ownerhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerhostname(), target);
  }

  // optional string ownerport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileResponse)
  return target;
}

size_t LookupFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileResponse)
  size_t total_size = 0;

  // required bool ifexists = 1;
  if (_internal_has_ifexists()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ownerhostname = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerhostname());
    }

    // optional string ownerport = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LookupFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileResponse::GetClassData() const { return &_class_data_; }


void LookupFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LookupFileResponse*>(&to_msg);
  auto& from = static_cast<const LookupFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ifexists_ = from._impl_.ifexists_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileResponse::CopyFrom(const LookupFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LookupFileResponse::InternalSwap(LookupFileResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerhostname_, lhs_arena,
      &other->_impl_.ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerport_, lhs_arena,
      &other->_impl_.ownerport_, rhs_arena
  );
  swap(_impl_.ifexists_, other->_impl_.ifexists_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[3]);
}

// ===================================================================

class fileInfoRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<fileInfoRequest>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

fileInfoRequest::fileInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.fileInfoRequest)
}
fileInfoRequest::fileInfoRequest(const fileInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  fileInfoRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    _this->_impl_.sourceport_.Set(from._internal_sourceport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.fileInfoRequest)
}

inline void fileInfoRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

fileInfoRequest::~fileInfoRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.fileInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void fileInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
  _impl_.sourceport_.Destroy();
}

void fileInfoRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void fileInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.fileInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* fileInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileInfoRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileInfoRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* fileInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.fileInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileInfoRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileInfoRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.fileInfoRequest)
  return target;
}

size_t fileInfoRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.fileInfoRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t fileInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.fileInfoRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData fileInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    fileInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*fileInfoRequest::GetClassData() const { return &_class_data_; }


void fileInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<fileInfoRequest*>(&to_msg);
  auto& from = static_cast<const fileInfoRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.fileInfoRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void fileInfoRequest::CopyFrom(const fileInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.fileInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fileInfoRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void fileInfoRequest::InternalSwap(fileInfoRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceport_, lhs_arena,
      &other->_impl_.sourceport_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata fileInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[4]);
}

// ===================================================================

class fileInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<fileInfoResponse>()._impl_._has_bits_);
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

fileInfoResponse::fileInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.fileInfoResponse)
}
fileInfoResponse::fileInfoResponse(const fileInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  fileInfoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    _this->_impl_.ownerhostname_.Set(from._internal_ownerhostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    _this->_impl_.ownerport_.Set(from._internal_ownerport(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.fileInfoResponse)
}

inline void fileInfoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}
  };
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

fileInfoResponse::~fileInfoResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.fileInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void fileInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ownerhostname_.Destroy();
  _impl_.ownerport_.Destroy();
}

void fileInfoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void fileInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.fileInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ownerport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* fileInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ownerhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileInfoResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileInfoResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* fileInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.fileInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string ownerhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileInfoResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileInfoResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.fileInfoResponse)
  return target;
}

size_t fileInfoResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.fileInfoResponse)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  return total_size;
}
size_t fileInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.fileInfoResponse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData fileInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    fileInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*fileInfoResponse::GetClassData() const { return &_class_data_; }


void fileInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<fileInfoResponse*>(&to_msg);
  auto& from = static_cast<const fileInfoResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.fileInfoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ownerport(from._internal_ownerport());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void fileInfoResponse::CopyFrom(const fileInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.fileInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fileInfoResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void fileInfoResponse::InternalSwap(fileInfoResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerhostname_, lhs_arena,
      &other->_impl_.ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerport_, lhs_arena,
      &other->_impl_.ownerport_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata fileInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[5]);
}

// ===================================================================

class downloadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<downloadRequest>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

downloadRequest::downloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.downloadRequest)
}
downloadRequest::downloadRequest(const downloadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  downloadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    _this->_impl_.sourceport_.Set(from._internal_sourceport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.downloadRequest)
}

inline void downloadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

downloadRequest::~downloadRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.downloadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void downloadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
  _impl_.sourceport_.Destroy();
}

void downloadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void downloadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.downloadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* downloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.downloadRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.downloadRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* downloadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.downloadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.downloadRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.downloadRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.downloadRequest)
  return target;
}

size_t downloadRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.downloadRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t downloadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.downloadRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData downloadRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    downloadRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*downloadRequest::GetClassData() const { return &_class_data_; }


void downloadRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<downloadRequest*>(&to_msg);
  auto& from = static_cast<const downloadRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.downloadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void downloadRequest::CopyFrom(const downloadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.downloadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool downloadRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void downloadRequest::InternalSwap(downloadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceport_, lhs_arena,
      &other->_impl_.sourceport_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata downloadRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[6]);
}

// ===================================================================

class joinRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<joinRequest>()._impl_._has_bits_);
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

joinRequest::joinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.joinRequest)
}
joinRequest::joinRequest(const joinRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  joinRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.hostnamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    _this->_impl_.sourcehostname_.Set(from._internal_sourcehostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    _this->_impl_.sourceport_.Set(from._internal_sourceport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.hostnamehash_ = from._impl_.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.joinRequest)
}

inline void joinRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcehostname_){}
    , decltype(_impl_.sourceport_){}
    , decltype(_impl_.hostnamehash_){int64_t{0}}
  };
  _impl_.sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

joinRequest::~joinRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.joinRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void joinRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcehostname_.Destroy();
  _impl_.sourceport_.Destroy();
}

void joinRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void joinRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.joinRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.hostnamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* joinRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string sourcehostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.joinRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.joinRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          _impl_.hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* joinRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.joinRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string sourcehostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.joinRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.joinRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourceport(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.joinRequest)
  return target;
}

size_t joinRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.joinRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t joinRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.joinRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData joinRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    joinRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*joinRequest::GetClassData() const { return &_class_data_; }


void joinRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<joinRequest*>(&to_msg);
  auto& from = static_cast<const joinRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.joinRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hostnamehash_ = from._impl_.hostnamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void joinRequest::CopyFrom(const joinRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.joinRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool joinRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void joinRequest::InternalSwap(joinRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcehostname_, lhs_arena,
      &other->_impl_.sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceport_, lhs_arena,
      &other->_impl_.sourceport_, rhs_arena
  );
  swap(_impl_.hostnamehash_, other->_impl_.hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata joinRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[7]);
}

// ===================================================================

class routeTableInit::_Internal {
 public:
};

routeTableInit::routeTableInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.routeTableInit)
}
routeTableInit::routeTableInit(const routeTableInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  routeTableInit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){from._impl_.entry_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.routeTableInit)
}

inline void routeTableInit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

routeTableInit::~routeTableInit() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.routeTableInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void routeTableInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entry_.~RepeatedPtrField();
}

void routeTableInit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void routeTableInit::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.routeTableInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* routeTableInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.routeTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* routeTableInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.routeTableInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.routeTableInit)
  return target;
}

size_t routeTableInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.routeTableInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->_impl_.entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData routeTableInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    routeTableInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*routeTableInit::GetClassData() const { return &_class_data_; }


void routeTableInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<routeTableInit*>(&to_msg);
  auto& from = static_cast<const routeTableInit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.routeTableInit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void routeTableInit::CopyFrom(const routeTableInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.routeTableInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool routeTableInit::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entry_))
    return false;
  return true;
}

void routeTableInit::InternalSwap(routeTableInit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata routeTableInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[8]);
}

// ===================================================================

class routeTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<routeTableEntry>()._impl_._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

routeTableEntry::routeTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.routeTableEntry)
}
routeTableEntry::routeTableEntry(const routeTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  routeTableEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.hostnamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_port()) {
    _this->_impl_.port_.Set(from._internal_port(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.hostnamehash_ = from._impl_.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.routeTableEntry)
}

inline void routeTableEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.hostnamehash_){int64_t{0}}
  };
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

routeTableEntry::~routeTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.routeTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void routeTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hostname_.Destroy();
  _impl_.port_.Destroy();
}

void routeTableEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void routeTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.routeTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.port_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.hostnamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* routeTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.routeTableEntry.hostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.routeTableEntry.port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          _impl_.hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* routeTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.routeTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.routeTableEntry.hostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  // required string port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_port().data(), static_cast<int>(this->_internal_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.routeTableEntry.port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_port(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.routeTableEntry)
  return target;
}

size_t routeTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.routeTableEntry)
  size_t total_size = 0;

  if (_internal_has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  if (_internal_has_port()) {
    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t routeTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.routeTableEntry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());

    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData routeTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    routeTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*routeTableEntry::GetClassData() const { return &_class_data_; }


void routeTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<routeTableEntry*>(&to_msg);
  auto& from = static_cast<const routeTableEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.routeTableEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_port(from._internal_port());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hostnamehash_ = from._impl_.hostnamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void routeTableEntry::CopyFrom(const routeTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.routeTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool routeTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void routeTableEntry::InternalSwap(routeTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.port_, lhs_arena,
      &other->_impl_.port_, rhs_arena
  );
  swap(_impl_.hostnamehash_, other->_impl_.hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata routeTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[9]);
}

// ===================================================================

class fileTable::_Internal {
 public:
};

fileTable::fileTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.fileTable)
}
fileTable::fileTable(const fileTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  fileTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){from._impl_.entry_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.fileTable)
}

inline void fileTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

fileTable::~fileTable() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.fileTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void fileTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entry_.~RepeatedPtrField();
}

void fileTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void fileTable::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.fileTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* fileTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.fileTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* fileTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.fileTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.fileTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.fileTable)
  return target;
}

size_t fileTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.fileTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.fileTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->_impl_.entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData fileTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    fileTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*fileTable::GetClassData() const { return &_class_data_; }


void fileTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<fileTable*>(&to_msg);
  auto& from = static_cast<const fileTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.fileTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void fileTable::CopyFrom(const fileTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.fileTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fileTable::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entry_))
    return false;
  return true;
}

void fileTable::InternalSwap(fileTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata fileTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[10]);
}

// ===================================================================

class fileTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<fileTableEntry>()._impl_._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

fileTableEntry::fileTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.fileTableEntry)
}
fileTableEntry::fileTableEntry(const fileTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  fileTableEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}
    , decltype(_impl_.filenamehash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    _this->_impl_.ownerhostname_.Set(from._internal_ownerhostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    _this->_impl_.ownerport_.Set(from._internal_ownerport(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.fileTableEntry)
}

inline void fileTableEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ownerhostname_){}
    , decltype(_impl_.ownerport_){}
    , decltype(_impl_.filenamehash_){int64_t{0}}
  };
  _impl_.ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

fileTableEntry::~fileTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.fileTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void fileTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ownerhostname_.Destroy();
  _impl_.ownerport_.Destroy();
}

void fileTableEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void fileTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.fileTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ownerport_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.filenamehash_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* fileTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          _impl_.filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ownerhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileTableEntry.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.fileTableEntry.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* fileTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.fileTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string ownerhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileTableEntry.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.fileTableEntry.ownerport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.fileTableEntry)
  return target;
}

size_t fileTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.fileTableEntry)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t fileTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.fileTableEntry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData fileTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    fileTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*fileTableEntry::GetClassData() const { return &_class_data_; }


void fileTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<fileTableEntry*>(&to_msg);
  auto& from = static_cast<const fileTableEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.fileTableEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filenamehash_ = from._impl_.filenamehash_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void fileTableEntry::CopyFrom(const fileTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.fileTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool fileTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void fileTableEntry::InternalSwap(fileTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerhostname_, lhs_arena,
      &other->_impl_.ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ownerport_, lhs_arena,
      &other->_impl_.ownerport_, rhs_arena
  );
  swap(_impl_.filenamehash_, other->_impl_.filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata fileTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[11]);
}

// ===================================================================

class routeInsertRequest::_Internal {
 public:
};

routeInsertRequest::routeInsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.routeInsertRequest)
}
routeInsertRequest::routeInsertRequest(const routeInsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  routeInsertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){from._impl_.entry_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.routeInsertRequest)
}

inline void routeInsertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

routeInsertRequest::~routeInsertRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.routeInsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void routeInsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entry_.~RepeatedPtrField();
}

void routeInsertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void routeInsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.routeInsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* routeInsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.routeTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* routeInsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.routeInsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.routeInsertRequest)
  return target;
}

size_t routeInsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.routeInsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->_impl_.entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData routeInsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    routeInsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*routeInsertRequest::GetClassData() const { return &_class_data_; }


void routeInsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<routeInsertRequest*>(&to_msg);
  auto& from = static_cast<const routeInsertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.routeInsertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void routeInsertRequest::CopyFrom(const routeInsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.routeInsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool routeInsertRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entry_))
    return false;
  return true;
}

void routeInsertRequest::InternalSwap(routeInsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata routeInsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[12]);
}

// ===================================================================

class routeDeleteRequest::_Internal {
 public:
};

routeDeleteRequest::routeDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.routeDeleteRequest)
}
routeDeleteRequest::routeDeleteRequest(const routeDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  routeDeleteRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){from._impl_.entry_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.routeDeleteRequest)
}

inline void routeDeleteRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entry_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

routeDeleteRequest::~routeDeleteRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.routeDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void routeDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entry_.~RepeatedPtrField();
}

void routeDeleteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void routeDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.routeDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* routeDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.routeTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* routeDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.routeDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.routeDeleteRequest)
  return target;
}

size_t routeDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.routeDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.routeTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->_impl_.entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData routeDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    routeDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*routeDeleteRequest::GetClassData() const { return &_class_data_; }


void routeDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<routeDeleteRequest*>(&to_msg);
  auto& from = static_cast<const routeDeleteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.routeDeleteRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entry_.MergeFrom(from._impl_.entry_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void routeDeleteRequest::CopyFrom(const routeDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.routeDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool routeDeleteRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entry_))
    return false;
  return true;
}

void routeDeleteRequest::InternalSwap(routeDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entry_.InternalSwap(&other->_impl_.entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata routeDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace p2pfilesharing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::p2pfilesharing::AddFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::AddFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::AddFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::DeleteFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::DeleteFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::DeleteFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::fileInfoRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::fileInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::fileInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::fileInfoResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::fileInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::fileInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::downloadRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::downloadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::downloadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::joinRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::joinRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::joinRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::routeTableInit*
Arena::CreateMaybeMessage< ::p2pfilesharing::routeTableInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::routeTableInit >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::routeTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::routeTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::routeTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::fileTable*
Arena::CreateMaybeMessage< ::p2pfilesharing::fileTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::fileTable >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::fileTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::fileTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::fileTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::routeInsertRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::routeInsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::routeInsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::routeDeleteRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::routeDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::routeDeleteRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
