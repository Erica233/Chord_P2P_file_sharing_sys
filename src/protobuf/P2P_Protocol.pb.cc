// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2P_Protocol.proto

#include "P2P_Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace p2pfilesharing {
PROTOBUF_CONSTEXPR AddFileRequest::AddFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct AddFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFileRequestDefaultTypeInternal() {}
  union {
    AddFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFileRequestDefaultTypeInternal _AddFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileRequest::LookupFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct LookupFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileRequestDefaultTypeInternal() {}
  union {
    LookupFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileRequestDefaultTypeInternal _LookupFileRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteFileRequest::DeleteFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct DeleteFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteFileRequestDefaultTypeInternal() {}
  union {
    DeleteFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileResponse::LookupFileResponse(
    ::_pbi::ConstantInitialized)
  : ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ifexists_(false){}
struct LookupFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileResponseDefaultTypeInternal() {}
  union {
    LookupFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileResponseDefaultTypeInternal _LookupFileResponse_default_instance_;
PROTOBUF_CONSTEXPR FileInfoRequest::FileInfoRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct FileInfoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileInfoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileInfoRequestDefaultTypeInternal() {}
  union {
    FileInfoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileInfoRequestDefaultTypeInternal _FileInfoRequest_default_instance_;
PROTOBUF_CONSTEXPR FileInfoResponse::FileInfoResponse(
    ::_pbi::ConstantInitialized)
  : ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct FileInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileInfoResponseDefaultTypeInternal() {}
  union {
    FileInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileInfoResponseDefaultTypeInternal _FileInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR DownloadRequest::DownloadRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct DownloadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadRequestDefaultTypeInternal() {}
  union {
    DownloadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinRequest::JoinRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hostnamehash_(int64_t{0}){}
struct JoinRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinRequestDefaultTypeInternal() {}
  union {
    JoinRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
PROTOBUF_CONSTEXPR RouteTableInit::RouteTableInit(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct RouteTableInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteTableInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteTableInitDefaultTypeInternal() {}
  union {
    RouteTableInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteTableInitDefaultTypeInternal _RouteTableInit_default_instance_;
PROTOBUF_CONSTEXPR RouteTableEntry::RouteTableEntry(
    ::_pbi::ConstantInitialized)
  : hostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , port_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hostnamehash_(int64_t{0}){}
struct RouteTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteTableEntryDefaultTypeInternal() {}
  union {
    RouteTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteTableEntryDefaultTypeInternal _RouteTableEntry_default_instance_;
PROTOBUF_CONSTEXPR FileTable::FileTable(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct FileTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileTableDefaultTypeInternal() {}
  union {
    FileTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileTableDefaultTypeInternal _FileTable_default_instance_;
PROTOBUF_CONSTEXPR FileTableEntry::FileTableEntry(
    ::_pbi::ConstantInitialized)
  : ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct FileTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileTableEntryDefaultTypeInternal() {}
  union {
    FileTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileTableEntryDefaultTypeInternal _FileTableEntry_default_instance_;
PROTOBUF_CONSTEXPR RouteInsertRequest::RouteInsertRequest(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct RouteInsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteInsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteInsertRequestDefaultTypeInternal() {}
  union {
    RouteInsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteInsertRequestDefaultTypeInternal _RouteInsertRequest_default_instance_;
PROTOBUF_CONSTEXPR RouteDeleteRequest::RouteDeleteRequest(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct RouteDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteDeleteRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteDeleteRequestDefaultTypeInternal() {}
  union {
    RouteDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteDeleteRequestDefaultTypeInternal _RouteDeleteRequest_default_instance_;
PROTOBUF_CONSTEXPR NodeRequest::NodeRequest(
    ::_pbi::ConstantInitialized)
  : addfile_(nullptr)
  , lookup_(nullptr)
  , delete__(nullptr)
  , fileinfo_(nullptr)
  , download_(nullptr)
  , join_(nullptr)
  , insertroute_(nullptr)
  , deleteroute_(nullptr)
  , type_(int64_t{0}){}
struct NodeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeRequestDefaultTypeInternal() {}
  union {
    NodeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
PROTOBUF_CONSTEXPR NodeResponse::NodeResponse(
    ::_pbi::ConstantInitialized)
  : lookup_(nullptr)
  , fileinforsp_(nullptr)
  , routeinit_(nullptr)
  , filetable_(nullptr)
  , type_(int64_t{0}){}
struct NodeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeResponseDefaultTypeInternal() {}
  union {
    NodeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
}  // namespace p2pfilesharing
static ::_pb::Metadata file_level_metadata_P2P_5fProtocol_2eproto[16];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_P2P_5fProtocol_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_P2P_5fProtocol_2eproto = nullptr;

const uint32_t TableStruct_P2P_5fProtocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, sourcehostname_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ifexists_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ownerport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, ownerport_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, sourceport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, hostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableInit, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, hostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, port_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, hostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTable, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, ownerport_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteInsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteInsertRequest, entry_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteDeleteRequest, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, type_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, addfile_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, lookup_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, delete__),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, fileinfo_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, download_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, join_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, insertroute_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, deleteroute_),
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, type_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, lookup_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, fileinforsp_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, routeinit_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, filetable_),
  4,
  0,
  1,
  2,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::p2pfilesharing::AddFileRequest)},
  { 10, 19, -1, sizeof(::p2pfilesharing::LookupFileRequest)},
  { 22, 31, -1, sizeof(::p2pfilesharing::DeleteFileRequest)},
  { 34, 43, -1, sizeof(::p2pfilesharing::LookupFileResponse)},
  { 46, 55, -1, sizeof(::p2pfilesharing::FileInfoRequest)},
  { 58, 66, -1, sizeof(::p2pfilesharing::FileInfoResponse)},
  { 68, 77, -1, sizeof(::p2pfilesharing::DownloadRequest)},
  { 80, 89, -1, sizeof(::p2pfilesharing::JoinRequest)},
  { 92, -1, -1, sizeof(::p2pfilesharing::RouteTableInit)},
  { 99, 108, -1, sizeof(::p2pfilesharing::RouteTableEntry)},
  { 111, -1, -1, sizeof(::p2pfilesharing::FileTable)},
  { 118, 127, -1, sizeof(::p2pfilesharing::FileTableEntry)},
  { 130, -1, -1, sizeof(::p2pfilesharing::RouteInsertRequest)},
  { 137, -1, -1, sizeof(::p2pfilesharing::RouteDeleteRequest)},
  { 144, 159, -1, sizeof(::p2pfilesharing::NodeRequest)},
  { 168, 179, -1, sizeof(::p2pfilesharing::NodeResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::p2pfilesharing::_AddFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileRequest_default_instance_._instance,
  &::p2pfilesharing::_DeleteFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileResponse_default_instance_._instance,
  &::p2pfilesharing::_FileInfoRequest_default_instance_._instance,
  &::p2pfilesharing::_FileInfoResponse_default_instance_._instance,
  &::p2pfilesharing::_DownloadRequest_default_instance_._instance,
  &::p2pfilesharing::_JoinRequest_default_instance_._instance,
  &::p2pfilesharing::_RouteTableInit_default_instance_._instance,
  &::p2pfilesharing::_RouteTableEntry_default_instance_._instance,
  &::p2pfilesharing::_FileTable_default_instance_._instance,
  &::p2pfilesharing::_FileTableEntry_default_instance_._instance,
  &::p2pfilesharing::_RouteInsertRequest_default_instance_._instance,
  &::p2pfilesharing::_RouteDeleteRequest_default_instance_._instance,
  &::p2pfilesharing::_NodeRequest_default_instance_._instance,
  &::p2pfilesharing::_NodeResponse_default_instance_._instance,
};

const char descriptor_table_protodef_P2P_5fProtocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022P2P_Protocol.proto\022\016p2pfilesharing\">\n\016"
  "AddFileRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016"
  "sourcehostname\030\002 \002(\t\"U\n\021LookupFileReques"
  "t\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016sourcehostnam"
  "e\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"U\n\021DeleteFil"
  "eRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016source"
  "hostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"P\n\022Lo"
  "okupFileResponse\022\020\n\010ifexists\030\001 \002(\010\022\025\n\row"
  "nerhostname\030\002 \001(\t\022\021\n\townerport\030\003 \001(\t\"S\n\017"
  "FileInfoRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n"
  "\016sourcehostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002("
  "\t\"<\n\020FileInfoResponse\022\025\n\rownerhostname\030\001"
  " \002(\t\022\021\n\townerport\030\002 \002(\t\"S\n\017DownloadReque"
  "st\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016sourcehostna"
  "me\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"O\n\013JoinRequ"
  "est\022\026\n\016sourcehostname\030\001 \002(\t\022\022\n\nsourcepor"
  "t\030\002 \002(\t\022\024\n\014hostnamehash\030\003 \002(\003\"@\n\016RouteTa"
  "bleInit\022.\n\005entry\030\001 \003(\0132\037.p2pfilesharing."
  "RouteTableEntry\"G\n\017RouteTableEntry\022\020\n\010ho"
  "stname\030\001 \002(\t\022\014\n\004port\030\002 \002(\t\022\024\n\014hostnameha"
  "sh\030\003 \002(\003\":\n\tFileTable\022-\n\005entry\030\001 \003(\0132\036.p"
  "2pfilesharing.FileTableEntry\"P\n\016FileTabl"
  "eEntry\022\024\n\014filenamehash\030\001 \002(\003\022\025\n\rownerhos"
  "tname\030\002 \002(\t\022\021\n\townerport\030\003 \002(\t\"D\n\022RouteI"
  "nsertRequest\022.\n\005entry\030\001 \003(\0132\037.p2pfilesha"
  "ring.RouteTableEntry\"D\n\022RouteDeleteReque"
  "st\022.\n\005entry\030\001 \003(\0132\037.p2pfilesharing.Route"
  "TableEntry\"\265\003\n\013NodeRequest\022\014\n\004type\030\001 \002(\003"
  "\022/\n\007addfile\030\002 \001(\0132\036.p2pfilesharing.AddFi"
  "leRequest\0221\n\006lookup\030\003 \001(\0132!.p2pfileshari"
  "ng.LookupFileRequest\0221\n\006delete\030\004 \001(\0132!.p"
  "2pfilesharing.DeleteFileRequest\0221\n\010filei"
  "nfo\030\005 \001(\0132\037.p2pfilesharing.FileInfoReque"
  "st\0221\n\010download\030\006 \001(\0132\037.p2pfilesharing.Do"
  "wnloadRequest\022)\n\004join\030\007 \001(\0132\033.p2pfilesha"
  "ring.JoinRequest\0227\n\013insertroute\030\010 \001(\0132\"."
  "p2pfilesharing.RouteInsertRequest\0227\n\013del"
  "eteroute\030\t \001(\0132\".p2pfilesharing.RouteDel"
  "eteRequest\"\350\001\n\014NodeResponse\022\014\n\004type\030\001 \002("
  "\003\0222\n\006lookup\030\002 \001(\0132\".p2pfilesharing.Looku"
  "pFileResponse\0225\n\013fileinforsp\030\003 \001(\0132 .p2p"
  "filesharing.FileInfoResponse\0221\n\trouteini"
  "t\030\004 \001(\0132\036.p2pfilesharing.RouteTableInit\022"
  ",\n\tfiletable\030\005 \001(\0132\031.p2pfilesharing.File"
  "Table"
  ;
static ::_pbi::once_flag descriptor_table_P2P_5fProtocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_P2P_5fProtocol_2eproto = {
    false, false, 1765, descriptor_table_protodef_P2P_5fProtocol_2eproto,
    "P2P_Protocol.proto",
    &descriptor_table_P2P_5fProtocol_2eproto_once, nullptr, 0, 16,
    schemas, file_default_instances, TableStruct_P2P_5fProtocol_2eproto::offsets,
    file_level_metadata_P2P_5fProtocol_2eproto, file_level_enum_descriptors_P2P_5fProtocol_2eproto,
    file_level_service_descriptors_P2P_5fProtocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_P2P_5fProtocol_2eproto_getter() {
  return &descriptor_table_P2P_5fProtocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_P2P_5fProtocol_2eproto(&descriptor_table_P2P_5fProtocol_2eproto);
namespace p2pfilesharing {

// ===================================================================

class AddFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AddFileRequest::AddFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.AddFileRequest)
}
AddFileRequest::AddFileRequest(const AddFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.AddFileRequest)
}

inline void AddFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

AddFileRequest::~AddFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.AddFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
}

void AddFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sourcehostname_.ClearNonDefaultToEmpty();
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.AddFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.AddFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.AddFileRequest)
  return target;
}

size_t AddFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t AddFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AddFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFileRequest::GetClassData() const { return &_class_data_; }

void AddFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddFileRequest *>(to)->MergeFrom(
      static_cast<const AddFileRequest &>(from));
}


void AddFileRequest::MergeFrom(const AddFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.AddFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFileRequest::CopyFrom(const AddFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.AddFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AddFileRequest::InternalSwap(AddFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[0]);
}

// ===================================================================

class LookupFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LookupFileRequest::LookupFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileRequest)
}
LookupFileRequest::LookupFileRequest(const LookupFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileRequest)
}

inline void LookupFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

LookupFileRequest::~LookupFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void LookupFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookupFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileRequest)
  return target;
}

size_t LookupFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t LookupFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LookupFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileRequest::GetClassData() const { return &_class_data_; }

void LookupFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LookupFileRequest *>(to)->MergeFrom(
      static_cast<const LookupFileRequest &>(from));
}


void LookupFileRequest::MergeFrom(const LookupFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileRequest::CopyFrom(const LookupFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LookupFileRequest::InternalSwap(LookupFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[1]);
}

// ===================================================================

class DeleteFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DeleteFileRequest::DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.DeleteFileRequest)
}
DeleteFileRequest::DeleteFileRequest(const DeleteFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.DeleteFileRequest)
}

inline void DeleteFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

DeleteFileRequest::~DeleteFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.DeleteFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void DeleteFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.DeleteFileRequest)
  return target;
}

size_t DeleteFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t DeleteFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteFileRequest::GetClassData() const { return &_class_data_; }

void DeleteFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteFileRequest *>(to)->MergeFrom(
      static_cast<const DeleteFileRequest &>(from));
}


void DeleteFileRequest::MergeFrom(const DeleteFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.DeleteFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteFileRequest::CopyFrom(const DeleteFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.DeleteFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DeleteFileRequest::InternalSwap(DeleteFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[2]);
}

// ===================================================================

class LookupFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileResponse>()._has_bits_);
  static void set_has_ifexists(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

LookupFileResponse::LookupFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileResponse)
}
LookupFileResponse::LookupFileResponse(const LookupFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  ifexists_ = from.ifexists_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileResponse)
}

inline void LookupFileResponse::SharedCtor() {
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ifexists_ = false;
}

LookupFileResponse::~LookupFileResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void LookupFileResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookupFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  ifexists_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool ifexists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ifexists(&has_bits);
          ifexists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ownerhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ownerport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool ifexists = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifexists(), target);
  }

  // optional string ownerhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerhostname(), target);
  }

  // optional string ownerport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileResponse)
  return target;
}

size_t LookupFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileResponse)
  size_t total_size = 0;

  // required bool ifexists = 1;
  if (_internal_has_ifexists()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ownerhostname = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerhostname());
    }

    // optional string ownerport = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LookupFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileResponse::GetClassData() const { return &_class_data_; }

void LookupFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LookupFileResponse *>(to)->MergeFrom(
      static_cast<const LookupFileResponse &>(from));
}


void LookupFileResponse::MergeFrom(const LookupFileResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000004u) {
      ifexists_ = from.ifexists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileResponse::CopyFrom(const LookupFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LookupFileResponse::InternalSwap(LookupFileResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
  swap(ifexists_, other->ifexists_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[3]);
}

// ===================================================================

class FileInfoRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FileInfoRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

FileInfoRequest::FileInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileInfoRequest)
}
FileInfoRequest::FileInfoRequest(const FileInfoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileInfoRequest)
}

inline void FileInfoRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

FileInfoRequest::~FileInfoRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileInfoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileInfoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void FileInfoRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileInfoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileInfoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileInfoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileInfoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileInfoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileInfoRequest)
  return target;
}

size_t FileInfoRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.FileInfoRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t FileInfoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileInfoRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileInfoRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileInfoRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileInfoRequest::GetClassData() const { return &_class_data_; }

void FileInfoRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileInfoRequest *>(to)->MergeFrom(
      static_cast<const FileInfoRequest &>(from));
}


void FileInfoRequest::MergeFrom(const FileInfoRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileInfoRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfoRequest::CopyFrom(const FileInfoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileInfoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfoRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FileInfoRequest::InternalSwap(FileInfoRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileInfoRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[4]);
}

// ===================================================================

class FileInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FileInfoResponse>()._has_bits_);
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

FileInfoResponse::FileInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileInfoResponse)
}
FileInfoResponse::FileInfoResponse(const FileInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileInfoResponse)
}

inline void FileInfoResponse::SharedCtor() {
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileInfoResponse::~FileInfoResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void FileInfoResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ownerhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ownerhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileInfoResponse)
  return target;
}

size_t FileInfoResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.FileInfoResponse)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  return total_size;
}
size_t FileInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileInfoResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileInfoResponse::GetClassData() const { return &_class_data_; }

void FileInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileInfoResponse *>(to)->MergeFrom(
      static_cast<const FileInfoResponse &>(from));
}


void FileInfoResponse::MergeFrom(const FileInfoResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileInfoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfoResponse::CopyFrom(const FileInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfoResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FileInfoResponse::InternalSwap(FileInfoResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FileInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[5]);
}

// ===================================================================

class DownloadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DownloadRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DownloadRequest::DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.DownloadRequest)
}
DownloadRequest::DownloadRequest(const DownloadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.DownloadRequest)
}

inline void DownloadRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

DownloadRequest::~DownloadRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.DownloadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void DownloadRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownloadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.DownloadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DownloadRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DownloadRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.DownloadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DownloadRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DownloadRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.DownloadRequest)
  return target;
}

size_t DownloadRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.DownloadRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t DownloadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.DownloadRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownloadRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DownloadRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownloadRequest::GetClassData() const { return &_class_data_; }

void DownloadRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DownloadRequest *>(to)->MergeFrom(
      static_cast<const DownloadRequest &>(from));
}


void DownloadRequest::MergeFrom(const DownloadRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.DownloadRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownloadRequest::CopyFrom(const DownloadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.DownloadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DownloadRequest::InternalSwap(DownloadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownloadRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[6]);
}

// ===================================================================

class JoinRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinRequest>()._has_bits_);
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

JoinRequest::JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.JoinRequest)
}
JoinRequest::JoinRequest(const JoinRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  hostnamehash_ = from.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.JoinRequest)
}

inline void JoinRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hostnamehash_ = int64_t{0};
}

JoinRequest::~JoinRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.JoinRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void JoinRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.JoinRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  hostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string sourcehostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.JoinRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.JoinRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.JoinRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string sourcehostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.JoinRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.JoinRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourceport(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.JoinRequest)
  return target;
}

size_t JoinRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.JoinRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t JoinRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.JoinRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    JoinRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinRequest::GetClassData() const { return &_class_data_; }

void JoinRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<JoinRequest *>(to)->MergeFrom(
      static_cast<const JoinRequest &>(from));
}


void JoinRequest::MergeFrom(const JoinRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.JoinRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      hostnamehash_ = from.hostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinRequest::CopyFrom(const JoinRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.JoinRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void JoinRequest::InternalSwap(JoinRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(hostnamehash_, other->hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[7]);
}

// ===================================================================

class RouteTableInit::_Internal {
 public:
};

RouteTableInit::RouteTableInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteTableInit)
}
RouteTableInit::RouteTableInit(const RouteTableInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteTableInit)
}

inline void RouteTableInit::SharedCtor() {
}

RouteTableInit::~RouteTableInit() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteTableInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteTableInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteTableInit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteTableInit::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteTableInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteTableInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.RouteTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteTableInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteTableInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteTableInit)
  return target;
}

size_t RouteTableInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteTableInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteTableInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteTableInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteTableInit::GetClassData() const { return &_class_data_; }

void RouteTableInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteTableInit *>(to)->MergeFrom(
      static_cast<const RouteTableInit &>(from));
}


void RouteTableInit::MergeFrom(const RouteTableInit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteTableInit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteTableInit::CopyFrom(const RouteTableInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteTableInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteTableInit::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void RouteTableInit::InternalSwap(RouteTableInit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteTableInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[8]);
}

// ===================================================================

class RouteTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteTableEntry>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

RouteTableEntry::RouteTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteTableEntry)
}
RouteTableEntry::RouteTableEntry(const RouteTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(from._internal_hostname(), 
      GetArenaForAllocation());
  }
  port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_port()) {
    port_.Set(from._internal_port(), 
      GetArenaForAllocation());
  }
  hostnamehash_ = from.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteTableEntry)
}

inline void RouteTableEntry::SharedCtor() {
hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  port_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hostnamehash_ = int64_t{0};
}

RouteTableEntry::~RouteTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.Destroy();
  port_.Destroy();
}

void RouteTableEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      port_.ClearNonDefaultToEmpty();
    }
  }
  hostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteTableEntry.hostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteTableEntry.port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteTableEntry.hostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  // required string port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_port().data(), static_cast<int>(this->_internal_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteTableEntry.port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_port(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteTableEntry)
  return target;
}

size_t RouteTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.RouteTableEntry)
  size_t total_size = 0;

  if (_internal_has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  if (_internal_has_port()) {
    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t RouteTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteTableEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());

    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteTableEntry::GetClassData() const { return &_class_data_; }

void RouteTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteTableEntry *>(to)->MergeFrom(
      static_cast<const RouteTableEntry &>(from));
}


void RouteTableEntry::MergeFrom(const RouteTableEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteTableEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_port(from._internal_port());
    }
    if (cached_has_bits & 0x00000004u) {
      hostnamehash_ = from.hostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteTableEntry::CopyFrom(const RouteTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RouteTableEntry::InternalSwap(RouteTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &port_, lhs_arena,
      &other->port_, rhs_arena
  );
  swap(hostnamehash_, other->hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[9]);
}

// ===================================================================

class FileTable::_Internal {
 public:
};

FileTable::FileTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileTable)
}
FileTable::FileTable(const FileTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileTable)
}

inline void FileTable::SharedCtor() {
}

FileTable::~FileTable() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FileTable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileTable::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.FileTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.FileTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileTable)
  return target;
}

size_t FileTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.FileTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileTable::GetClassData() const { return &_class_data_; }

void FileTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileTable *>(to)->MergeFrom(
      static_cast<const FileTable &>(from));
}


void FileTable::MergeFrom(const FileTable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileTable)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileTable::CopyFrom(const FileTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTable::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void FileTable::InternalSwap(FileTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[10]);
}

// ===================================================================

class FileTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<FileTableEntry>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

FileTableEntry::FileTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileTableEntry)
}
FileTableEntry::FileTableEntry(const FileTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileTableEntry)
}

inline void FileTableEntry::SharedCtor() {
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

FileTableEntry::~FileTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void FileTableEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ownerhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileTableEntry.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileTableEntry.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string ownerhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileTableEntry.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileTableEntry.ownerport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileTableEntry)
  return target;
}

size_t FileTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.FileTableEntry)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t FileTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileTableEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileTableEntry::GetClassData() const { return &_class_data_; }

void FileTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileTableEntry *>(to)->MergeFrom(
      static_cast<const FileTableEntry &>(from));
}


void FileTableEntry::MergeFrom(const FileTableEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileTableEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileTableEntry::CopyFrom(const FileTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FileTableEntry::InternalSwap(FileTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[11]);
}

// ===================================================================

class RouteInsertRequest::_Internal {
 public:
};

RouteInsertRequest::RouteInsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteInsertRequest)
}
RouteInsertRequest::RouteInsertRequest(const RouteInsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteInsertRequest)
}

inline void RouteInsertRequest::SharedCtor() {
}

RouteInsertRequest::~RouteInsertRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteInsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteInsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteInsertRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteInsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteInsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteInsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.RouteTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteInsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteInsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteInsertRequest)
  return target;
}

size_t RouteInsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteInsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteInsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteInsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteInsertRequest::GetClassData() const { return &_class_data_; }

void RouteInsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteInsertRequest *>(to)->MergeFrom(
      static_cast<const RouteInsertRequest &>(from));
}


void RouteInsertRequest::MergeFrom(const RouteInsertRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteInsertRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteInsertRequest::CopyFrom(const RouteInsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteInsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteInsertRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void RouteInsertRequest::InternalSwap(RouteInsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteInsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[12]);
}

// ===================================================================

class RouteDeleteRequest::_Internal {
 public:
};

RouteDeleteRequest::RouteDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteDeleteRequest)
}
RouteDeleteRequest::RouteDeleteRequest(const RouteDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteDeleteRequest)
}

inline void RouteDeleteRequest::SharedCtor() {
}

RouteDeleteRequest::~RouteDeleteRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.RouteTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteDeleteRequest)
  return target;
}

size_t RouteDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteDeleteRequest::GetClassData() const { return &_class_data_; }

void RouteDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteDeleteRequest *>(to)->MergeFrom(
      static_cast<const RouteDeleteRequest &>(from));
}


void RouteDeleteRequest::MergeFrom(const RouteDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteDeleteRequest::CopyFrom(const RouteDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteDeleteRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void RouteDeleteRequest::InternalSwap(RouteDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[13]);
}

// ===================================================================

class NodeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeRequest>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::p2pfilesharing::AddFileRequest& addfile(const NodeRequest* msg);
  static void set_has_addfile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::p2pfilesharing::LookupFileRequest& lookup(const NodeRequest* msg);
  static void set_has_lookup(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::p2pfilesharing::DeleteFileRequest& delete_(const NodeRequest* msg);
  static void set_has_delete_(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::p2pfilesharing::FileInfoRequest& fileinfo(const NodeRequest* msg);
  static void set_has_fileinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::p2pfilesharing::DownloadRequest& download(const NodeRequest* msg);
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::p2pfilesharing::JoinRequest& join(const NodeRequest* msg);
  static void set_has_join(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::p2pfilesharing::RouteInsertRequest& insertroute(const NodeRequest* msg);
  static void set_has_insertroute(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::p2pfilesharing::RouteDeleteRequest& deleteroute(const NodeRequest* msg);
  static void set_has_deleteroute(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000100) ^ 0x00000100) != 0;
  }
};

const ::p2pfilesharing::AddFileRequest&
NodeRequest::_Internal::addfile(const NodeRequest* msg) {
  return *msg->addfile_;
}
const ::p2pfilesharing::LookupFileRequest&
NodeRequest::_Internal::lookup(const NodeRequest* msg) {
  return *msg->lookup_;
}
const ::p2pfilesharing::DeleteFileRequest&
NodeRequest::_Internal::delete_(const NodeRequest* msg) {
  return *msg->delete__;
}
const ::p2pfilesharing::FileInfoRequest&
NodeRequest::_Internal::fileinfo(const NodeRequest* msg) {
  return *msg->fileinfo_;
}
const ::p2pfilesharing::DownloadRequest&
NodeRequest::_Internal::download(const NodeRequest* msg) {
  return *msg->download_;
}
const ::p2pfilesharing::JoinRequest&
NodeRequest::_Internal::join(const NodeRequest* msg) {
  return *msg->join_;
}
const ::p2pfilesharing::RouteInsertRequest&
NodeRequest::_Internal::insertroute(const NodeRequest* msg) {
  return *msg->insertroute_;
}
const ::p2pfilesharing::RouteDeleteRequest&
NodeRequest::_Internal::deleteroute(const NodeRequest* msg) {
  return *msg->deleteroute_;
}
NodeRequest::NodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.NodeRequest)
}
NodeRequest::NodeRequest(const NodeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_addfile()) {
    addfile_ = new ::p2pfilesharing::AddFileRequest(*from.addfile_);
  } else {
    addfile_ = nullptr;
  }
  if (from._internal_has_lookup()) {
    lookup_ = new ::p2pfilesharing::LookupFileRequest(*from.lookup_);
  } else {
    lookup_ = nullptr;
  }
  if (from._internal_has_delete_()) {
    delete__ = new ::p2pfilesharing::DeleteFileRequest(*from.delete__);
  } else {
    delete__ = nullptr;
  }
  if (from._internal_has_fileinfo()) {
    fileinfo_ = new ::p2pfilesharing::FileInfoRequest(*from.fileinfo_);
  } else {
    fileinfo_ = nullptr;
  }
  if (from._internal_has_download()) {
    download_ = new ::p2pfilesharing::DownloadRequest(*from.download_);
  } else {
    download_ = nullptr;
  }
  if (from._internal_has_join()) {
    join_ = new ::p2pfilesharing::JoinRequest(*from.join_);
  } else {
    join_ = nullptr;
  }
  if (from._internal_has_insertroute()) {
    insertroute_ = new ::p2pfilesharing::RouteInsertRequest(*from.insertroute_);
  } else {
    insertroute_ = nullptr;
  }
  if (from._internal_has_deleteroute()) {
    deleteroute_ = new ::p2pfilesharing::RouteDeleteRequest(*from.deleteroute_);
  } else {
    deleteroute_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.NodeRequest)
}

inline void NodeRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&addfile_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&addfile_)) + sizeof(type_));
}

NodeRequest::~NodeRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.NodeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete addfile_;
  if (this != internal_default_instance()) delete lookup_;
  if (this != internal_default_instance()) delete delete__;
  if (this != internal_default_instance()) delete fileinfo_;
  if (this != internal_default_instance()) delete download_;
  if (this != internal_default_instance()) delete join_;
  if (this != internal_default_instance()) delete insertroute_;
  if (this != internal_default_instance()) delete deleteroute_;
}

void NodeRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.NodeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(addfile_ != nullptr);
      addfile_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lookup_ != nullptr);
      lookup_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(delete__ != nullptr);
      delete__->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(fileinfo_ != nullptr);
      fileinfo_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(download_ != nullptr);
      download_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(join_ != nullptr);
      join_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(insertroute_ != nullptr);
      insertroute_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(deleteroute_ != nullptr);
      deleteroute_->Clear();
    }
  }
  type_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.AddFileRequest addfile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_addfile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.LookupFileRequest lookup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.DeleteFileRequest delete = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_delete_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.FileInfoRequest fileinfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.DownloadRequest download = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.JoinRequest join = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_join(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteInsertRequest insertroute = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_insertroute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleteroute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.NodeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 type = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_type(), target);
  }

  // optional .p2pfilesharing.AddFileRequest addfile = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::addfile(this),
        _Internal::addfile(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.LookupFileRequest lookup = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lookup(this),
        _Internal::lookup(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.DeleteFileRequest delete = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::delete_(this),
        _Internal::delete_(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.FileInfoRequest fileinfo = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.DownloadRequest download = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::download(this),
        _Internal::download(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.JoinRequest join = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::join(this),
        _Internal::join(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteInsertRequest insertroute = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::insertroute(this),
        _Internal::insertroute(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::deleteroute(this),
        _Internal::deleteroute(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.NodeRequest)
  return target;
}

size_t NodeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.NodeRequest)
  size_t total_size = 0;

  // required int64 type = 1;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .p2pfilesharing.AddFileRequest addfile = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addfile_);
    }

    // optional .p2pfilesharing.LookupFileRequest lookup = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookup_);
    }

    // optional .p2pfilesharing.DeleteFileRequest delete = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *delete__);
    }

    // optional .p2pfilesharing.FileInfoRequest fileinfo = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fileinfo_);
    }

    // optional .p2pfilesharing.DownloadRequest download = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *download_);
    }

    // optional .p2pfilesharing.JoinRequest join = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *join_);
    }

    // optional .p2pfilesharing.RouteInsertRequest insertroute = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *insertroute_);
    }

    // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *deleteroute_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NodeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeRequest::GetClassData() const { return &_class_data_; }

void NodeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NodeRequest *>(to)->MergeFrom(
      static_cast<const NodeRequest &>(from));
}


void NodeRequest::MergeFrom(const NodeRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.NodeRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_addfile()->::p2pfilesharing::AddFileRequest::MergeFrom(from._internal_addfile());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lookup()->::p2pfilesharing::LookupFileRequest::MergeFrom(from._internal_lookup());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_delete_()->::p2pfilesharing::DeleteFileRequest::MergeFrom(from._internal_delete_());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_fileinfo()->::p2pfilesharing::FileInfoRequest::MergeFrom(from._internal_fileinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_download()->::p2pfilesharing::DownloadRequest::MergeFrom(from._internal_download());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_join()->::p2pfilesharing::JoinRequest::MergeFrom(from._internal_join());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_insertroute()->::p2pfilesharing::RouteInsertRequest::MergeFrom(from._internal_insertroute());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_deleteroute()->::p2pfilesharing::RouteDeleteRequest::MergeFrom(from._internal_deleteroute());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeRequest::CopyFrom(const NodeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.NodeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_addfile()) {
    if (!addfile_->IsInitialized()) return false;
  }
  if (_internal_has_lookup()) {
    if (!lookup_->IsInitialized()) return false;
  }
  if (_internal_has_delete_()) {
    if (!delete__->IsInitialized()) return false;
  }
  if (_internal_has_fileinfo()) {
    if (!fileinfo_->IsInitialized()) return false;
  }
  if (_internal_has_download()) {
    if (!download_->IsInitialized()) return false;
  }
  if (_internal_has_join()) {
    if (!join_->IsInitialized()) return false;
  }
  if (_internal_has_insertroute()) {
    if (!insertroute_->IsInitialized()) return false;
  }
  if (_internal_has_deleteroute()) {
    if (!deleteroute_->IsInitialized()) return false;
  }
  return true;
}

void NodeRequest::InternalSwap(NodeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeRequest, type_)
      + sizeof(NodeRequest::type_)
      - PROTOBUF_FIELD_OFFSET(NodeRequest, addfile_)>(
          reinterpret_cast<char*>(&addfile_),
          reinterpret_cast<char*>(&other->addfile_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[14]);
}

// ===================================================================

class NodeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeResponse>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::p2pfilesharing::LookupFileResponse& lookup(const NodeResponse* msg);
  static void set_has_lookup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::p2pfilesharing::FileInfoResponse& fileinforsp(const NodeResponse* msg);
  static void set_has_fileinforsp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::p2pfilesharing::RouteTableInit& routeinit(const NodeResponse* msg);
  static void set_has_routeinit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::p2pfilesharing::FileTable& filetable(const NodeResponse* msg);
  static void set_has_filetable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

const ::p2pfilesharing::LookupFileResponse&
NodeResponse::_Internal::lookup(const NodeResponse* msg) {
  return *msg->lookup_;
}
const ::p2pfilesharing::FileInfoResponse&
NodeResponse::_Internal::fileinforsp(const NodeResponse* msg) {
  return *msg->fileinforsp_;
}
const ::p2pfilesharing::RouteTableInit&
NodeResponse::_Internal::routeinit(const NodeResponse* msg) {
  return *msg->routeinit_;
}
const ::p2pfilesharing::FileTable&
NodeResponse::_Internal::filetable(const NodeResponse* msg) {
  return *msg->filetable_;
}
NodeResponse::NodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.NodeResponse)
}
NodeResponse::NodeResponse(const NodeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lookup()) {
    lookup_ = new ::p2pfilesharing::LookupFileResponse(*from.lookup_);
  } else {
    lookup_ = nullptr;
  }
  if (from._internal_has_fileinforsp()) {
    fileinforsp_ = new ::p2pfilesharing::FileInfoResponse(*from.fileinforsp_);
  } else {
    fileinforsp_ = nullptr;
  }
  if (from._internal_has_routeinit()) {
    routeinit_ = new ::p2pfilesharing::RouteTableInit(*from.routeinit_);
  } else {
    routeinit_ = nullptr;
  }
  if (from._internal_has_filetable()) {
    filetable_ = new ::p2pfilesharing::FileTable(*from.filetable_);
  } else {
    filetable_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.NodeResponse)
}

inline void NodeResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lookup_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&lookup_)) + sizeof(type_));
}

NodeResponse::~NodeResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.NodeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete lookup_;
  if (this != internal_default_instance()) delete fileinforsp_;
  if (this != internal_default_instance()) delete routeinit_;
  if (this != internal_default_instance()) delete filetable_;
}

void NodeResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.NodeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(lookup_ != nullptr);
      lookup_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fileinforsp_ != nullptr);
      fileinforsp_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(routeinit_ != nullptr);
      routeinit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(filetable_ != nullptr);
      filetable_->Clear();
    }
  }
  type_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.LookupFileResponse lookup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinforsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteTableInit routeinit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_routeinit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.FileTable filetable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_filetable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.NodeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_type(), target);
  }

  // optional .p2pfilesharing.LookupFileResponse lookup = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::lookup(this),
        _Internal::lookup(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fileinforsp(this),
        _Internal::fileinforsp(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteTableInit routeinit = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::routeinit(this),
        _Internal::routeinit(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.FileTable filetable = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::filetable(this),
        _Internal::filetable(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.NodeResponse)
  return target;
}

size_t NodeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.NodeResponse)
  size_t total_size = 0;

  // required int64 type = 1;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .p2pfilesharing.LookupFileResponse lookup = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookup_);
    }

    // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fileinforsp_);
    }

    // optional .p2pfilesharing.RouteTableInit routeinit = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *routeinit_);
    }

    // optional .p2pfilesharing.FileTable filetable = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filetable_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NodeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeResponse::GetClassData() const { return &_class_data_; }

void NodeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NodeResponse *>(to)->MergeFrom(
      static_cast<const NodeResponse &>(from));
}


void NodeResponse::MergeFrom(const NodeResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.NodeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_lookup()->::p2pfilesharing::LookupFileResponse::MergeFrom(from._internal_lookup());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fileinforsp()->::p2pfilesharing::FileInfoResponse::MergeFrom(from._internal_fileinforsp());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_routeinit()->::p2pfilesharing::RouteTableInit::MergeFrom(from._internal_routeinit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_filetable()->::p2pfilesharing::FileTable::MergeFrom(from._internal_filetable());
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeResponse::CopyFrom(const NodeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.NodeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_lookup()) {
    if (!lookup_->IsInitialized()) return false;
  }
  if (_internal_has_fileinforsp()) {
    if (!fileinforsp_->IsInitialized()) return false;
  }
  if (_internal_has_routeinit()) {
    if (!routeinit_->IsInitialized()) return false;
  }
  if (_internal_has_filetable()) {
    if (!filetable_->IsInitialized()) return false;
  }
  return true;
}

void NodeResponse::InternalSwap(NodeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeResponse, type_)
      + sizeof(NodeResponse::type_)
      - PROTOBUF_FIELD_OFFSET(NodeResponse, lookup_)>(
          reinterpret_cast<char*>(&lookup_),
          reinterpret_cast<char*>(&other->lookup_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace p2pfilesharing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::p2pfilesharing::AddFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::AddFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::AddFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::DeleteFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::DeleteFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::DeleteFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileInfoRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileInfoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileInfoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileInfoResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::DownloadRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::DownloadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::DownloadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::JoinRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::JoinRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::JoinRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteTableInit*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteTableInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteTableInit >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileTable*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileTable >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteInsertRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteInsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteInsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteDeleteRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::NodeRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::NodeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::NodeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::NodeResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::NodeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::NodeResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
