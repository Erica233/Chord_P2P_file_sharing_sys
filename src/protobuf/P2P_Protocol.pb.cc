// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2P_Protocol.proto

#include "P2P_Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace p2pfilesharing {
PROTOBUF_CONSTEXPR AddFileRequest::AddFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct AddFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFileRequestDefaultTypeInternal() {}
  union {
    AddFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFileRequestDefaultTypeInternal _AddFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileRequest::LookupFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct LookupFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileRequestDefaultTypeInternal() {}
  union {
    LookupFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileRequestDefaultTypeInternal _LookupFileRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteFileRequest::DeleteFileRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct DeleteFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteFileRequestDefaultTypeInternal() {}
  union {
    DeleteFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupFileResponse::LookupFileResponse(
    ::_pbi::ConstantInitialized)
  : successorhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , successorport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ifexists_(false){}
struct LookupFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupFileResponseDefaultTypeInternal() {}
  union {
    LookupFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupFileResponseDefaultTypeInternal _LookupFileResponse_default_instance_;
PROTOBUF_CONSTEXPR FileInfoResponse::FileInfoResponse(
    ::_pbi::ConstantInitialized)
  : ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct FileInfoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileInfoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileInfoResponseDefaultTypeInternal() {}
  union {
    FileInfoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileInfoResponseDefaultTypeInternal _FileInfoResponse_default_instance_;
PROTOBUF_CONSTEXPR DownloadRequest::DownloadRequest(
    ::_pbi::ConstantInitialized)
  : sourcehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sourceport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct DownloadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadRequestDefaultTypeInternal() {}
  union {
    DownloadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinRequest::JoinRequest(
    ::_pbi::ConstantInitialized)
  : newhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newhostnamehash_(int64_t{0}){}
struct JoinRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JoinRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JoinRequestDefaultTypeInternal() {}
  union {
    JoinRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinRequestDefaultTypeInternal _JoinRequest_default_instance_;
PROTOBUF_CONSTEXPR RouteTableInit::RouteTableInit(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct RouteTableInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteTableInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteTableInitDefaultTypeInternal() {}
  union {
    RouteTableInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteTableInitDefaultTypeInternal _RouteTableInit_default_instance_;
PROTOBUF_CONSTEXPR RouteTableEntry::RouteTableEntry(
    ::_pbi::ConstantInitialized)
  : hostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , port_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hostnamehash_(int64_t{0}){}
struct RouteTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteTableEntryDefaultTypeInternal() {}
  union {
    RouteTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteTableEntryDefaultTypeInternal _RouteTableEntry_default_instance_;
PROTOBUF_CONSTEXPR FileTable::FileTable(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct FileTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileTableDefaultTypeInternal() {}
  union {
    FileTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileTableDefaultTypeInternal _FileTable_default_instance_;
PROTOBUF_CONSTEXPR FileTableEntry::FileTableEntry(
    ::_pbi::ConstantInitialized)
  : ownerhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ownerport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filenamehash_(int64_t{0}){}
struct FileTableEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileTableEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileTableEntryDefaultTypeInternal() {}
  union {
    FileTableEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileTableEntryDefaultTypeInternal _FileTableEntry_default_instance_;
PROTOBUF_CONSTEXPR RouteUpdateRequest::RouteUpdateRequest(
    ::_pbi::ConstantInitialized)
  : newhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newhostnamehash_(int64_t{0}){}
struct RouteUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteUpdateRequestDefaultTypeInternal() {}
  union {
    RouteUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteUpdateRequestDefaultTypeInternal _RouteUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR RouteUpdateResponse::RouteUpdateResponse(
    ::_pbi::ConstantInitialized)
  : nextupdatehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , nextupdateport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , nextupdatehostnamehash_(int64_t{0})
  , curupdatehostnamehash_(int64_t{0}){}
struct RouteUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteUpdateResponseDefaultTypeInternal() {}
  union {
    RouteUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteUpdateResponseDefaultTypeInternal _RouteUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR RouteDeleteRequest::RouteDeleteRequest(
    ::_pbi::ConstantInitialized)
  : entry_(){}
struct RouteDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteDeleteRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteDeleteRequestDefaultTypeInternal() {}
  union {
    RouteDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteDeleteRequestDefaultTypeInternal _RouteDeleteRequest_default_instance_;
PROTOBUF_CONSTEXPR HelpJoinRequset::HelpJoinRequset(
    ::_pbi::ConstantInitialized)
  : newhostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newhostnamehash_(int64_t{0}){}
struct HelpJoinRequsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HelpJoinRequsetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HelpJoinRequsetDefaultTypeInternal() {}
  union {
    HelpJoinRequset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HelpJoinRequsetDefaultTypeInternal _HelpJoinRequset_default_instance_;
PROTOBUF_CONSTEXPR HelpJoinResponse::HelpJoinResponse(
    ::_pbi::ConstantInitialized)
  : responsiblehostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , responsibleport_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , responhostnamehash_(int64_t{0}){}
struct HelpJoinResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HelpJoinResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HelpJoinResponseDefaultTypeInternal() {}
  union {
    HelpJoinResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HelpJoinResponseDefaultTypeInternal _HelpJoinResponse_default_instance_;
PROTOBUF_CONSTEXPR LookupNodeResponse::LookupNodeResponse(
    ::_pbi::ConstantInitialized)
  : hostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , port_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hostnamehash_(int64_t{0}){}
struct LookupNodeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LookupNodeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LookupNodeResponseDefaultTypeInternal() {}
  union {
    LookupNodeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupNodeResponseDefaultTypeInternal _LookupNodeResponse_default_instance_;
PROTOBUF_CONSTEXPR NodeRequest::NodeRequest(
    ::_pbi::ConstantInitialized)
  : addfile_(nullptr)
  , lookup_(nullptr)
  , deletefile_(nullptr)
  , download_(nullptr)
  , join_(nullptr)
  , updateroute_(nullptr)
  , deleteroute_(nullptr)
  , helpjoin_(nullptr)
  , type_(int64_t{0}){}
struct NodeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeRequestDefaultTypeInternal() {}
  union {
    NodeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
PROTOBUF_CONSTEXPR NodeResponse::NodeResponse(
    ::_pbi::ConstantInitialized)
  : lookup_(nullptr)
  , fileinforsp_(nullptr)
  , routeinit_(nullptr)
  , filetable_(nullptr)
  , helpjoin_(nullptr)
  , updateroute_(nullptr)
  , lookupnode_(nullptr)
  , type_(int64_t{0}){}
struct NodeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeResponseDefaultTypeInternal() {}
  union {
    NodeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
}  // namespace p2pfilesharing
static ::_pb::Metadata file_level_metadata_P2P_5fProtocol_2eproto[19];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_P2P_5fProtocol_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_P2P_5fProtocol_2eproto = nullptr;

const uint32_t TableStruct_P2P_5fProtocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::AddFileRequest, sourcehostname_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DeleteFileRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ifexists_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, successorhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, successorport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupFileResponse, ownerport_),
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileInfoResponse, ownerport_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, sourcehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::DownloadRequest, sourceport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, newhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, newport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::JoinRequest, newhostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableInit, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, hostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, port_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteTableEntry, hostnamehash_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTable, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, filenamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, ownerhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::FileTableEntry, ownerport_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateRequest, newhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateRequest, newport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateRequest, newhostnamehash_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, nextupdatehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, nextupdateport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, nextupdatehostnamehash_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteUpdateResponse, curupdatehostnamehash_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::RouteDeleteRequest, entry_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinRequset, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinRequset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinRequset, newhostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinRequset, newport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinRequset, newhostnamehash_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinResponse, responsiblehostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinResponse, responsibleport_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::HelpJoinResponse, responhostnamehash_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupNodeResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupNodeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupNodeResponse, hostname_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupNodeResponse, port_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::LookupNodeResponse, hostnamehash_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, type_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, addfile_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, lookup_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, deletefile_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, download_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, join_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, updateroute_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, deleteroute_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeRequest, helpjoin_),
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, type_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, lookup_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, fileinforsp_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, routeinit_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, filetable_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, helpjoin_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, updateroute_),
  PROTOBUF_FIELD_OFFSET(::p2pfilesharing::NodeResponse, lookupnode_),
  7,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::p2pfilesharing::AddFileRequest)},
  { 10, 19, -1, sizeof(::p2pfilesharing::LookupFileRequest)},
  { 22, 31, -1, sizeof(::p2pfilesharing::DeleteFileRequest)},
  { 34, 45, -1, sizeof(::p2pfilesharing::LookupFileResponse)},
  { 50, 58, -1, sizeof(::p2pfilesharing::FileInfoResponse)},
  { 60, 69, -1, sizeof(::p2pfilesharing::DownloadRequest)},
  { 72, 81, -1, sizeof(::p2pfilesharing::JoinRequest)},
  { 84, -1, -1, sizeof(::p2pfilesharing::RouteTableInit)},
  { 91, 100, -1, sizeof(::p2pfilesharing::RouteTableEntry)},
  { 103, -1, -1, sizeof(::p2pfilesharing::FileTable)},
  { 110, 119, -1, sizeof(::p2pfilesharing::FileTableEntry)},
  { 122, 131, -1, sizeof(::p2pfilesharing::RouteUpdateRequest)},
  { 134, 144, -1, sizeof(::p2pfilesharing::RouteUpdateResponse)},
  { 148, -1, -1, sizeof(::p2pfilesharing::RouteDeleteRequest)},
  { 155, 164, -1, sizeof(::p2pfilesharing::HelpJoinRequset)},
  { 167, 176, -1, sizeof(::p2pfilesharing::HelpJoinResponse)},
  { 179, 188, -1, sizeof(::p2pfilesharing::LookupNodeResponse)},
  { 191, 206, -1, sizeof(::p2pfilesharing::NodeRequest)},
  { 215, 229, -1, sizeof(::p2pfilesharing::NodeResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::p2pfilesharing::_AddFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileRequest_default_instance_._instance,
  &::p2pfilesharing::_DeleteFileRequest_default_instance_._instance,
  &::p2pfilesharing::_LookupFileResponse_default_instance_._instance,
  &::p2pfilesharing::_FileInfoResponse_default_instance_._instance,
  &::p2pfilesharing::_DownloadRequest_default_instance_._instance,
  &::p2pfilesharing::_JoinRequest_default_instance_._instance,
  &::p2pfilesharing::_RouteTableInit_default_instance_._instance,
  &::p2pfilesharing::_RouteTableEntry_default_instance_._instance,
  &::p2pfilesharing::_FileTable_default_instance_._instance,
  &::p2pfilesharing::_FileTableEntry_default_instance_._instance,
  &::p2pfilesharing::_RouteUpdateRequest_default_instance_._instance,
  &::p2pfilesharing::_RouteUpdateResponse_default_instance_._instance,
  &::p2pfilesharing::_RouteDeleteRequest_default_instance_._instance,
  &::p2pfilesharing::_HelpJoinRequset_default_instance_._instance,
  &::p2pfilesharing::_HelpJoinResponse_default_instance_._instance,
  &::p2pfilesharing::_LookupNodeResponse_default_instance_._instance,
  &::p2pfilesharing::_NodeRequest_default_instance_._instance,
  &::p2pfilesharing::_NodeResponse_default_instance_._instance,
};

const char descriptor_table_protodef_P2P_5fProtocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022P2P_Protocol.proto\022\016p2pfilesharing\">\n\016"
  "AddFileRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016"
  "sourcehostname\030\002 \002(\t\"U\n\021LookupFileReques"
  "t\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016sourcehostnam"
  "e\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"U\n\021DeleteFil"
  "eRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016source"
  "hostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"\202\001\n\022L"
  "ookupFileResponse\022\020\n\010ifexists\030\001 \002(\010\022\031\n\021s"
  "uccessorhostname\030\002 \002(\t\022\025\n\rsuccessorport\030"
  "\003 \002(\t\022\025\n\rownerhostname\030\004 \001(\t\022\021\n\townerpor"
  "t\030\005 \001(\t\"<\n\020FileInfoResponse\022\025\n\rownerhost"
  "name\030\001 \002(\t\022\021\n\townerport\030\002 \002(\t\"S\n\017Downloa"
  "dRequest\022\024\n\014filenamehash\030\001 \002(\003\022\026\n\016source"
  "hostname\030\002 \002(\t\022\022\n\nsourceport\030\003 \002(\t\"L\n\013Jo"
  "inRequest\022\023\n\013newhostname\030\001 \002(\t\022\017\n\007newpor"
  "t\030\002 \002(\t\022\027\n\017newhostnamehash\030\003 \002(\003\"@\n\016Rout"
  "eTableInit\022.\n\005entry\030\001 \003(\0132\037.p2pfileshari"
  "ng.RouteTableEntry\"G\n\017RouteTableEntry\022\020\n"
  "\010hostname\030\001 \002(\t\022\014\n\004port\030\002 \002(\t\022\024\n\014hostnam"
  "ehash\030\003 \002(\003\":\n\tFileTable\022-\n\005entry\030\001 \003(\0132"
  "\036.p2pfilesharing.FileTableEntry\"P\n\016FileT"
  "ableEntry\022\024\n\014filenamehash\030\001 \002(\003\022\025\n\rowner"
  "hostname\030\002 \002(\t\022\021\n\townerport\030\003 \002(\t\"S\n\022Rou"
  "teUpdateRequest\022\023\n\013newhostname\030\001 \002(\t\022\017\n\007"
  "newport\030\002 \002(\t\022\027\n\017newhostnamehash\030\003 \002(\003\"\210"
  "\001\n\023RouteUpdateResponse\022\032\n\022nextupdatehost"
  "name\030\001 \002(\t\022\026\n\016nextupdateport\030\002 \002(\t\022\036\n\026ne"
  "xtupdatehostnamehash\030\003 \002(\003\022\035\n\025curupdateh"
  "ostnamehash\030\004 \002(\003\"D\n\022RouteDeleteRequest\022"
  ".\n\005entry\030\001 \003(\0132\037.p2pfilesharing.RouteTab"
  "leEntry\"P\n\017HelpJoinRequset\022\023\n\013newhostnam"
  "e\030\001 \002(\t\022\017\n\007newport\030\002 \002(\t\022\027\n\017newhostnameh"
  "ash\030\003 \002(\003\"d\n\020HelpJoinResponse\022\033\n\023respons"
  "iblehostname\030\001 \002(\t\022\027\n\017responsibleport\030\002 "
  "\002(\t\022\032\n\022responhostnamehash\030\003 \002(\003\"J\n\022Looku"
  "pNodeResponse\022\020\n\010hostname\030\001 \002(\t\022\014\n\004port\030"
  "\002 \002(\t\022\024\n\014hostnamehash\030\003 \002(\003\"\271\003\n\013NodeRequ"
  "est\022\014\n\004type\030\001 \002(\003\022/\n\007addfile\030\002 \001(\0132\036.p2p"
  "filesharing.AddFileRequest\0221\n\006lookup\030\003 \001"
  "(\0132!.p2pfilesharing.LookupFileRequest\0225\n"
  "\ndeletefile\030\004 \001(\0132!.p2pfilesharing.Delet"
  "eFileRequest\0221\n\010download\030\005 \001(\0132\037.p2pfile"
  "sharing.DownloadRequest\022)\n\004join\030\006 \001(\0132\033."
  "p2pfilesharing.JoinRequest\0227\n\013updaterout"
  "e\030\007 \001(\0132\".p2pfilesharing.RouteUpdateRequ"
  "est\0227\n\013deleteroute\030\010 \001(\0132\".p2pfilesharin"
  "g.RouteDeleteRequest\0221\n\010helpjoin\030\t \001(\0132\037"
  ".p2pfilesharing.HelpJoinRequset\"\216\003\n\014Node"
  "Response\022\014\n\004type\030\001 \002(\003\0222\n\006lookup\030\002 \001(\0132\""
  ".p2pfilesharing.LookupFileResponse\0225\n\013fi"
  "leinforsp\030\003 \001(\0132 .p2pfilesharing.FileInf"
  "oResponse\0221\n\trouteinit\030\004 \001(\0132\036.p2pfilesh"
  "aring.RouteTableInit\022,\n\tfiletable\030\005 \001(\0132"
  "\031.p2pfilesharing.FileTable\0222\n\010helpjoin\030\006"
  " \001(\0132 .p2pfilesharing.HelpJoinResponse\0228"
  "\n\013updateroute\030\007 \001(\0132#.p2pfilesharing.Rou"
  "teUpdateResponse\0226\n\nlookupnode\030\010 \001(\0132\".p"
  "2pfilesharing.LookupNodeResponse"
  ;
static ::_pbi::once_flag descriptor_table_P2P_5fProtocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_P2P_5fProtocol_2eproto = {
    false, false, 2312, descriptor_table_protodef_P2P_5fProtocol_2eproto,
    "P2P_Protocol.proto",
    &descriptor_table_P2P_5fProtocol_2eproto_once, nullptr, 0, 19,
    schemas, file_default_instances, TableStruct_P2P_5fProtocol_2eproto::offsets,
    file_level_metadata_P2P_5fProtocol_2eproto, file_level_enum_descriptors_P2P_5fProtocol_2eproto,
    file_level_service_descriptors_P2P_5fProtocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_P2P_5fProtocol_2eproto_getter() {
  return &descriptor_table_P2P_5fProtocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_P2P_5fProtocol_2eproto(&descriptor_table_P2P_5fProtocol_2eproto);
namespace p2pfilesharing {

// ===================================================================

class AddFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AddFileRequest::AddFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.AddFileRequest)
}
AddFileRequest::AddFileRequest(const AddFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.AddFileRequest)
}

inline void AddFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

AddFileRequest::~AddFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.AddFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
}

void AddFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sourcehostname_.ClearNonDefaultToEmpty();
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.AddFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.AddFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.AddFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.AddFileRequest)
  return target;
}

size_t AddFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t AddFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.AddFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AddFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFileRequest::GetClassData() const { return &_class_data_; }

void AddFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddFileRequest *>(to)->MergeFrom(
      static_cast<const AddFileRequest &>(from));
}


void AddFileRequest::MergeFrom(const AddFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.AddFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFileRequest::CopyFrom(const AddFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.AddFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AddFileRequest::InternalSwap(AddFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[0]);
}

// ===================================================================

class LookupFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LookupFileRequest::LookupFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileRequest)
}
LookupFileRequest::LookupFileRequest(const LookupFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileRequest)
}

inline void LookupFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

LookupFileRequest::~LookupFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void LookupFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookupFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileRequest)
  return target;
}

size_t LookupFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t LookupFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LookupFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileRequest::GetClassData() const { return &_class_data_; }

void LookupFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LookupFileRequest *>(to)->MergeFrom(
      static_cast<const LookupFileRequest &>(from));
}


void LookupFileRequest::MergeFrom(const LookupFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileRequest::CopyFrom(const LookupFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LookupFileRequest::InternalSwap(LookupFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[1]);
}

// ===================================================================

class DeleteFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteFileRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DeleteFileRequest::DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.DeleteFileRequest)
}
DeleteFileRequest::DeleteFileRequest(const DeleteFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.DeleteFileRequest)
}

inline void DeleteFileRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

DeleteFileRequest::~DeleteFileRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.DeleteFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void DeleteFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DeleteFileRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.DeleteFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DeleteFileRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.DeleteFileRequest)
  return target;
}

size_t DeleteFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t DeleteFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.DeleteFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteFileRequest::GetClassData() const { return &_class_data_; }

void DeleteFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteFileRequest *>(to)->MergeFrom(
      static_cast<const DeleteFileRequest &>(from));
}


void DeleteFileRequest::MergeFrom(const DeleteFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.DeleteFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteFileRequest::CopyFrom(const DeleteFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.DeleteFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DeleteFileRequest::InternalSwap(DeleteFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[2]);
}

// ===================================================================

class LookupFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupFileResponse>()._has_bits_);
  static void set_has_ifexists(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_successorhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_successorport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000013) ^ 0x00000013) != 0;
  }
};

LookupFileResponse::LookupFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupFileResponse)
}
LookupFileResponse::LookupFileResponse(const LookupFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  successorhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    successorhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_successorhostname()) {
    successorhostname_.Set(from._internal_successorhostname(), 
      GetArenaForAllocation());
  }
  successorport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    successorport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_successorport()) {
    successorport_.Set(from._internal_successorport(), 
      GetArenaForAllocation());
  }
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  ifexists_ = from.ifexists_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupFileResponse)
}

inline void LookupFileResponse::SharedCtor() {
successorhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  successorhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
successorport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  successorport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ifexists_ = false;
}

LookupFileResponse::~LookupFileResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  successorhostname_.Destroy();
  successorport_.Destroy();
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void LookupFileResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookupFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      successorhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      successorport_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  ifexists_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool ifexists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ifexists(&has_bits);
          ifexists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string successorhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_successorhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.successorhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string successorport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_successorport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.successorport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ownerhostname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string ownerport = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupFileResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool ifexists = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifexists(), target);
  }

  // required string successorhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_successorhostname().data(), static_cast<int>(this->_internal_successorhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.successorhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_successorhostname(), target);
  }

  // required string successorport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_successorport().data(), static_cast<int>(this->_internal_successorport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.successorport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_successorport(), target);
  }

  // optional string ownerhostname = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ownerhostname(), target);
  }

  // optional string ownerport = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupFileResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupFileResponse)
  return target;
}

size_t LookupFileResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.LookupFileResponse)
  size_t total_size = 0;

  if (_internal_has_successorhostname()) {
    // required string successorhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_successorhostname());
  }

  if (_internal_has_successorport()) {
    // required string successorport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_successorport());
  }

  if (_internal_has_ifexists()) {
    // required bool ifexists = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t LookupFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupFileResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000013) ^ 0x00000013) == 0) {  // All required fields are present.
    // required string successorhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_successorhostname());

    // required string successorport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_successorport());

    // required bool ifexists = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional string ownerhostname = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerhostname());
    }

    // optional string ownerport = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ownerport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LookupFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupFileResponse::GetClassData() const { return &_class_data_; }

void LookupFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LookupFileResponse *>(to)->MergeFrom(
      static_cast<const LookupFileResponse &>(from));
}


void LookupFileResponse::MergeFrom(const LookupFileResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupFileResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_successorhostname(from._internal_successorhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_successorport(from._internal_successorport());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000010u) {
      ifexists_ = from.ifexists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupFileResponse::CopyFrom(const LookupFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupFileResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LookupFileResponse::InternalSwap(LookupFileResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &successorhostname_, lhs_arena,
      &other->successorhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &successorport_, lhs_arena,
      &other->successorport_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
  swap(ifexists_, other->ifexists_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[3]);
}

// ===================================================================

class FileInfoResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FileInfoResponse>()._has_bits_);
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

FileInfoResponse::FileInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileInfoResponse)
}
FileInfoResponse::FileInfoResponse(const FileInfoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileInfoResponse)
}

inline void FileInfoResponse::SharedCtor() {
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileInfoResponse::~FileInfoResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileInfoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileInfoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void FileInfoResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileInfoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileInfoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileInfoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ownerhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoResponse.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileInfoResponse.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileInfoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileInfoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ownerhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoResponse.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileInfoResponse.ownerport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileInfoResponse)
  return target;
}

size_t FileInfoResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.FileInfoResponse)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  return total_size;
}
size_t FileInfoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileInfoResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ownerhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileInfoResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileInfoResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileInfoResponse::GetClassData() const { return &_class_data_; }

void FileInfoResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileInfoResponse *>(to)->MergeFrom(
      static_cast<const FileInfoResponse &>(from));
}


void FileInfoResponse::MergeFrom(const FileInfoResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileInfoResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfoResponse::CopyFrom(const FileInfoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileInfoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfoResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FileInfoResponse::InternalSwap(FileInfoResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FileInfoResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[4]);
}

// ===================================================================

class DownloadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DownloadRequest>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DownloadRequest::DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.DownloadRequest)
}
DownloadRequest::DownloadRequest(const DownloadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sourcehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourcehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcehostname()) {
    sourcehostname_.Set(from._internal_sourcehostname(), 
      GetArenaForAllocation());
  }
  sourceport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sourceport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceport()) {
    sourceport_.Set(from._internal_sourceport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.DownloadRequest)
}

inline void DownloadRequest::SharedCtor() {
sourcehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourcehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sourceport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sourceport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

DownloadRequest::~DownloadRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.DownloadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sourcehostname_.Destroy();
  sourceport_.Destroy();
}

void DownloadRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownloadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.DownloadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sourcehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sourceport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string sourcehostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourcehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DownloadRequest.sourcehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string sourceport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourceport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.DownloadRequest.sourceport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.DownloadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string sourcehostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcehostname().data(), static_cast<int>(this->_internal_sourcehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DownloadRequest.sourcehostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcehostname(), target);
  }

  // required string sourceport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceport().data(), static_cast<int>(this->_internal_sourceport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.DownloadRequest.sourceport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourceport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.DownloadRequest)
  return target;
}

size_t DownloadRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.DownloadRequest)
  size_t total_size = 0;

  if (_internal_has_sourcehostname()) {
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());
  }

  if (_internal_has_sourceport()) {
    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t DownloadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.DownloadRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string sourcehostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcehostname());

    // required string sourceport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourceport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownloadRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DownloadRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownloadRequest::GetClassData() const { return &_class_data_; }

void DownloadRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DownloadRequest *>(to)->MergeFrom(
      static_cast<const DownloadRequest &>(from));
}


void DownloadRequest::MergeFrom(const DownloadRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.DownloadRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sourcehostname(from._internal_sourcehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sourceport(from._internal_sourceport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownloadRequest::CopyFrom(const DownloadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.DownloadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DownloadRequest::InternalSwap(DownloadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourcehostname_, lhs_arena,
      &other->sourcehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sourceport_, lhs_arena,
      &other->sourceport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownloadRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[5]);
}

// ===================================================================

class JoinRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinRequest>()._has_bits_);
  static void set_has_newhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_newhostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

JoinRequest::JoinRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.JoinRequest)
}
JoinRequest::JoinRequest(const JoinRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  newhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newhostname()) {
    newhostname_.Set(from._internal_newhostname(), 
      GetArenaForAllocation());
  }
  newport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newport()) {
    newport_.Set(from._internal_newport(), 
      GetArenaForAllocation());
  }
  newhostnamehash_ = from.newhostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.JoinRequest)
}

inline void JoinRequest::SharedCtor() {
newhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newhostnamehash_ = int64_t{0};
}

JoinRequest::~JoinRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.JoinRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JoinRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  newhostname_.Destroy();
  newport_.Destroy();
}

void JoinRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.JoinRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      newhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      newport_.ClearNonDefaultToEmpty();
    }
  }
  newhostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string newhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.JoinRequest.newhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string newport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_newport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.JoinRequest.newport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 newhostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_newhostnamehash(&has_bits);
          newhostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JoinRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.JoinRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string newhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newhostname().data(), static_cast<int>(this->_internal_newhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.JoinRequest.newhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newhostname(), target);
  }

  // required string newport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newport().data(), static_cast<int>(this->_internal_newport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.JoinRequest.newport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_newport(), target);
  }

  // required int64 newhostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_newhostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.JoinRequest)
  return target;
}

size_t JoinRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.JoinRequest)
  size_t total_size = 0;

  if (_internal_has_newhostname()) {
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());
  }

  if (_internal_has_newport()) {
    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());
  }

  if (_internal_has_newhostnamehash()) {
    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());
  }

  return total_size;
}
size_t JoinRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.JoinRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());

    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());

    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    JoinRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinRequest::GetClassData() const { return &_class_data_; }

void JoinRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<JoinRequest *>(to)->MergeFrom(
      static_cast<const JoinRequest &>(from));
}


void JoinRequest::MergeFrom(const JoinRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.JoinRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_newhostname(from._internal_newhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_newport(from._internal_newport());
    }
    if (cached_has_bits & 0x00000004u) {
      newhostnamehash_ = from.newhostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinRequest::CopyFrom(const JoinRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.JoinRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void JoinRequest::InternalSwap(JoinRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newhostname_, lhs_arena,
      &other->newhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newport_, lhs_arena,
      &other->newport_, rhs_arena
  );
  swap(newhostnamehash_, other->newhostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[6]);
}

// ===================================================================

class RouteTableInit::_Internal {
 public:
};

RouteTableInit::RouteTableInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteTableInit)
}
RouteTableInit::RouteTableInit(const RouteTableInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteTableInit)
}

inline void RouteTableInit::SharedCtor() {
}

RouteTableInit::~RouteTableInit() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteTableInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteTableInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteTableInit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteTableInit::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteTableInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteTableInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.RouteTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteTableInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteTableInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteTableInit)
  return target;
}

size_t RouteTableInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteTableInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteTableInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteTableInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteTableInit::GetClassData() const { return &_class_data_; }

void RouteTableInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteTableInit *>(to)->MergeFrom(
      static_cast<const RouteTableInit &>(from));
}


void RouteTableInit::MergeFrom(const RouteTableInit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteTableInit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteTableInit::CopyFrom(const RouteTableInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteTableInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteTableInit::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void RouteTableInit::InternalSwap(RouteTableInit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteTableInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[7]);
}

// ===================================================================

class RouteTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteTableEntry>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

RouteTableEntry::RouteTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteTableEntry)
}
RouteTableEntry::RouteTableEntry(const RouteTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(from._internal_hostname(), 
      GetArenaForAllocation());
  }
  port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_port()) {
    port_.Set(from._internal_port(), 
      GetArenaForAllocation());
  }
  hostnamehash_ = from.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteTableEntry)
}

inline void RouteTableEntry::SharedCtor() {
hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  port_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hostnamehash_ = int64_t{0};
}

RouteTableEntry::~RouteTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.Destroy();
  port_.Destroy();
}

void RouteTableEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      port_.ClearNonDefaultToEmpty();
    }
  }
  hostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteTableEntry.hostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteTableEntry.port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteTableEntry.hostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  // required string port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_port().data(), static_cast<int>(this->_internal_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteTableEntry.port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_port(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteTableEntry)
  return target;
}

size_t RouteTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.RouteTableEntry)
  size_t total_size = 0;

  if (_internal_has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  if (_internal_has_port()) {
    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t RouteTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteTableEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());

    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteTableEntry::GetClassData() const { return &_class_data_; }

void RouteTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteTableEntry *>(to)->MergeFrom(
      static_cast<const RouteTableEntry &>(from));
}


void RouteTableEntry::MergeFrom(const RouteTableEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteTableEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_port(from._internal_port());
    }
    if (cached_has_bits & 0x00000004u) {
      hostnamehash_ = from.hostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteTableEntry::CopyFrom(const RouteTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RouteTableEntry::InternalSwap(RouteTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &port_, lhs_arena,
      &other->port_, rhs_arena
  );
  swap(hostnamehash_, other->hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[8]);
}

// ===================================================================

class FileTable::_Internal {
 public:
};

FileTable::FileTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileTable)
}
FileTable::FileTable(const FileTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileTable)
}

inline void FileTable::SharedCtor() {
}

FileTable::~FileTable() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FileTable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileTable::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.FileTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.FileTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileTable)
  return target;
}

size_t FileTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.FileTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileTable::GetClassData() const { return &_class_data_; }

void FileTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileTable *>(to)->MergeFrom(
      static_cast<const FileTable &>(from));
}


void FileTable::MergeFrom(const FileTable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileTable)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileTable::CopyFrom(const FileTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTable::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void FileTable::InternalSwap(FileTable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[9]);
}

// ===================================================================

class FileTableEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<FileTableEntry>()._has_bits_);
  static void set_has_filenamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ownerhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ownerport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

FileTableEntry::FileTableEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.FileTableEntry)
}
FileTableEntry::FileTableEntry(const FileTableEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ownerhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerhostname()) {
    ownerhostname_.Set(from._internal_ownerhostname(), 
      GetArenaForAllocation());
  }
  ownerport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ownerport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ownerport()) {
    ownerport_.Set(from._internal_ownerport(), 
      GetArenaForAllocation());
  }
  filenamehash_ = from.filenamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.FileTableEntry)
}

inline void FileTableEntry::SharedCtor() {
ownerhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ownerport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ownerport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filenamehash_ = int64_t{0};
}

FileTableEntry::~FileTableEntry() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.FileTableEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileTableEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ownerhostname_.Destroy();
  ownerport_.Destroy();
}

void FileTableEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FileTableEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.FileTableEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ownerhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ownerport_.ClearNonDefaultToEmpty();
    }
  }
  filenamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileTableEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 filenamehash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_filenamehash(&has_bits);
          filenamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ownerhostname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ownerhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileTableEntry.ownerhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string ownerport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ownerport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.FileTableEntry.ownerport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileTableEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.FileTableEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 filenamehash = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_filenamehash(), target);
  }

  // required string ownerhostname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerhostname().data(), static_cast<int>(this->_internal_ownerhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileTableEntry.ownerhostname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ownerhostname(), target);
  }

  // required string ownerport = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ownerport().data(), static_cast<int>(this->_internal_ownerport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.FileTableEntry.ownerport");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ownerport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.FileTableEntry)
  return target;
}

size_t FileTableEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.FileTableEntry)
  size_t total_size = 0;

  if (_internal_has_ownerhostname()) {
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());
  }

  if (_internal_has_ownerport()) {
    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());
  }

  if (_internal_has_filenamehash()) {
    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());
  }

  return total_size;
}
size_t FileTableEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.FileTableEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string ownerhostname = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerhostname());

    // required string ownerport = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ownerport());

    // required int64 filenamehash = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filenamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileTableEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FileTableEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileTableEntry::GetClassData() const { return &_class_data_; }

void FileTableEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FileTableEntry *>(to)->MergeFrom(
      static_cast<const FileTableEntry &>(from));
}


void FileTableEntry::MergeFrom(const FileTableEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.FileTableEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ownerhostname(from._internal_ownerhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ownerport(from._internal_ownerport());
    }
    if (cached_has_bits & 0x00000004u) {
      filenamehash_ = from.filenamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileTableEntry::CopyFrom(const FileTableEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.FileTableEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTableEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void FileTableEntry::InternalSwap(FileTableEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerhostname_, lhs_arena,
      &other->ownerhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ownerport_, lhs_arena,
      &other->ownerport_, rhs_arena
  );
  swap(filenamehash_, other->filenamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileTableEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[10]);
}

// ===================================================================

class RouteUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteUpdateRequest>()._has_bits_);
  static void set_has_newhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_newhostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

RouteUpdateRequest::RouteUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteUpdateRequest)
}
RouteUpdateRequest::RouteUpdateRequest(const RouteUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  newhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newhostname()) {
    newhostname_.Set(from._internal_newhostname(), 
      GetArenaForAllocation());
  }
  newport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newport()) {
    newport_.Set(from._internal_newport(), 
      GetArenaForAllocation());
  }
  newhostnamehash_ = from.newhostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteUpdateRequest)
}

inline void RouteUpdateRequest::SharedCtor() {
newhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newhostnamehash_ = int64_t{0};
}

RouteUpdateRequest::~RouteUpdateRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  newhostname_.Destroy();
  newport_.Destroy();
}

void RouteUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      newhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      newport_.ClearNonDefaultToEmpty();
    }
  }
  newhostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string newhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteUpdateRequest.newhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string newport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_newport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteUpdateRequest.newport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 newhostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_newhostnamehash(&has_bits);
          newhostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string newhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newhostname().data(), static_cast<int>(this->_internal_newhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteUpdateRequest.newhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newhostname(), target);
  }

  // required string newport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newport().data(), static_cast<int>(this->_internal_newport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteUpdateRequest.newport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_newport(), target);
  }

  // required int64 newhostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_newhostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteUpdateRequest)
  return target;
}

size_t RouteUpdateRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.RouteUpdateRequest)
  size_t total_size = 0;

  if (_internal_has_newhostname()) {
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());
  }

  if (_internal_has_newport()) {
    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());
  }

  if (_internal_has_newhostnamehash()) {
    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());
  }

  return total_size;
}
size_t RouteUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteUpdateRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());

    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());

    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteUpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteUpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteUpdateRequest::GetClassData() const { return &_class_data_; }

void RouteUpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteUpdateRequest *>(to)->MergeFrom(
      static_cast<const RouteUpdateRequest &>(from));
}


void RouteUpdateRequest::MergeFrom(const RouteUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_newhostname(from._internal_newhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_newport(from._internal_newport());
    }
    if (cached_has_bits & 0x00000004u) {
      newhostnamehash_ = from.newhostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteUpdateRequest::CopyFrom(const RouteUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteUpdateRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RouteUpdateRequest::InternalSwap(RouteUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newhostname_, lhs_arena,
      &other->newhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newport_, lhs_arena,
      &other->newport_, rhs_arena
  );
  swap(newhostnamehash_, other->newhostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteUpdateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[11]);
}

// ===================================================================

class RouteUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteUpdateResponse>()._has_bits_);
  static void set_has_nextupdatehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nextupdateport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nextupdatehostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_curupdatehostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

RouteUpdateResponse::RouteUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteUpdateResponse)
}
RouteUpdateResponse::RouteUpdateResponse(const RouteUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nextupdatehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nextupdatehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextupdatehostname()) {
    nextupdatehostname_.Set(from._internal_nextupdatehostname(), 
      GetArenaForAllocation());
  }
  nextupdateport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nextupdateport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextupdateport()) {
    nextupdateport_.Set(from._internal_nextupdateport(), 
      GetArenaForAllocation());
  }
  ::memcpy(&nextupdatehostnamehash_, &from.nextupdatehostnamehash_,
    static_cast<size_t>(reinterpret_cast<char*>(&curupdatehostnamehash_) -
    reinterpret_cast<char*>(&nextupdatehostnamehash_)) + sizeof(curupdatehostnamehash_));
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteUpdateResponse)
}

inline void RouteUpdateResponse::SharedCtor() {
nextupdatehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nextupdatehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nextupdateport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nextupdateport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nextupdatehostnamehash_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&curupdatehostnamehash_) -
    reinterpret_cast<char*>(&nextupdatehostnamehash_)) + sizeof(curupdatehostnamehash_));
}

RouteUpdateResponse::~RouteUpdateResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nextupdatehostname_.Destroy();
  nextupdateport_.Destroy();
}

void RouteUpdateResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      nextupdatehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nextupdateport_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&nextupdatehostnamehash_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&curupdatehostnamehash_) -
        reinterpret_cast<char*>(&nextupdatehostnamehash_)) + sizeof(curupdatehostnamehash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string nextupdatehostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nextupdatehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteUpdateResponse.nextupdatehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string nextupdateport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nextupdateport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.RouteUpdateResponse.nextupdateport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 nextupdatehostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nextupdatehostnamehash(&has_bits);
          nextupdatehostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 curupdatehostnamehash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_curupdatehostnamehash(&has_bits);
          curupdatehostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string nextupdatehostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nextupdatehostname().data(), static_cast<int>(this->_internal_nextupdatehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteUpdateResponse.nextupdatehostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nextupdatehostname(), target);
  }

  // required string nextupdateport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nextupdateport().data(), static_cast<int>(this->_internal_nextupdateport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.RouteUpdateResponse.nextupdateport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nextupdateport(), target);
  }

  // required int64 nextupdatehostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_nextupdatehostnamehash(), target);
  }

  // required int64 curupdatehostnamehash = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_curupdatehostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteUpdateResponse)
  return target;
}

size_t RouteUpdateResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.RouteUpdateResponse)
  size_t total_size = 0;

  if (_internal_has_nextupdatehostname()) {
    // required string nextupdatehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nextupdatehostname());
  }

  if (_internal_has_nextupdateport()) {
    // required string nextupdateport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nextupdateport());
  }

  if (_internal_has_nextupdatehostnamehash()) {
    // required int64 nextupdatehostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nextupdatehostnamehash());
  }

  if (_internal_has_curupdatehostnamehash()) {
    // required int64 curupdatehostnamehash = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_curupdatehostnamehash());
  }

  return total_size;
}
size_t RouteUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteUpdateResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string nextupdatehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nextupdatehostname());

    // required string nextupdateport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nextupdateport());

    // required int64 nextupdatehostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nextupdatehostnamehash());

    // required int64 curupdatehostnamehash = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_curupdatehostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteUpdateResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteUpdateResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteUpdateResponse::GetClassData() const { return &_class_data_; }

void RouteUpdateResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteUpdateResponse *>(to)->MergeFrom(
      static_cast<const RouteUpdateResponse &>(from));
}


void RouteUpdateResponse::MergeFrom(const RouteUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteUpdateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_nextupdatehostname(from._internal_nextupdatehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nextupdateport(from._internal_nextupdateport());
    }
    if (cached_has_bits & 0x00000004u) {
      nextupdatehostnamehash_ = from.nextupdatehostnamehash_;
    }
    if (cached_has_bits & 0x00000008u) {
      curupdatehostnamehash_ = from.curupdatehostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteUpdateResponse::CopyFrom(const RouteUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteUpdateResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RouteUpdateResponse::InternalSwap(RouteUpdateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &nextupdatehostname_, lhs_arena,
      &other->nextupdatehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &nextupdateport_, lhs_arena,
      &other->nextupdateport_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouteUpdateResponse, curupdatehostnamehash_)
      + sizeof(RouteUpdateResponse::curupdatehostnamehash_)
      - PROTOBUF_FIELD_OFFSET(RouteUpdateResponse, nextupdatehostnamehash_)>(
          reinterpret_cast<char*>(&nextupdatehostnamehash_),
          reinterpret_cast<char*>(&other->nextupdatehostnamehash_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteUpdateResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[12]);
}

// ===================================================================

class RouteDeleteRequest::_Internal {
 public:
};

RouteDeleteRequest::RouteDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entry_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.RouteDeleteRequest)
}
RouteDeleteRequest::RouteDeleteRequest(const RouteDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entry_(from.entry_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.RouteDeleteRequest)
}

inline void RouteDeleteRequest::SharedCtor() {
}

RouteDeleteRequest::~RouteDeleteRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.RouteDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RouteDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RouteDeleteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RouteDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.RouteDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RouteDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .p2pfilesharing.RouteTableEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RouteDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.RouteDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.RouteDeleteRequest)
  return target;
}

size_t RouteDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.RouteDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .p2pfilesharing.RouteTableEntry entry = 1;
  total_size += 1UL * this->_internal_entry_size();
  for (const auto& msg : this->entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RouteDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RouteDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RouteDeleteRequest::GetClassData() const { return &_class_data_; }

void RouteDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RouteDeleteRequest *>(to)->MergeFrom(
      static_cast<const RouteDeleteRequest &>(from));
}


void RouteDeleteRequest::MergeFrom(const RouteDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.RouteDeleteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entry_.MergeFrom(from.entry_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RouteDeleteRequest::CopyFrom(const RouteDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.RouteDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteDeleteRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entry_))
    return false;
  return true;
}

void RouteDeleteRequest::InternalSwap(RouteDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entry_.InternalSwap(&other->entry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RouteDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[13]);
}

// ===================================================================

class HelpJoinRequset::_Internal {
 public:
  using HasBits = decltype(std::declval<HelpJoinRequset>()._has_bits_);
  static void set_has_newhostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_newhostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

HelpJoinRequset::HelpJoinRequset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.HelpJoinRequset)
}
HelpJoinRequset::HelpJoinRequset(const HelpJoinRequset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  newhostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newhostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newhostname()) {
    newhostname_.Set(from._internal_newhostname(), 
      GetArenaForAllocation());
  }
  newport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newport()) {
    newport_.Set(from._internal_newport(), 
      GetArenaForAllocation());
  }
  newhostnamehash_ = from.newhostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.HelpJoinRequset)
}

inline void HelpJoinRequset::SharedCtor() {
newhostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newhostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
newhostnamehash_ = int64_t{0};
}

HelpJoinRequset::~HelpJoinRequset() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.HelpJoinRequset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HelpJoinRequset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  newhostname_.Destroy();
  newport_.Destroy();
}

void HelpJoinRequset::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HelpJoinRequset::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.HelpJoinRequset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      newhostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      newport_.ClearNonDefaultToEmpty();
    }
  }
  newhostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HelpJoinRequset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string newhostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newhostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.HelpJoinRequset.newhostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string newport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_newport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.HelpJoinRequset.newport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 newhostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_newhostnamehash(&has_bits);
          newhostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HelpJoinRequset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.HelpJoinRequset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string newhostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newhostname().data(), static_cast<int>(this->_internal_newhostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.HelpJoinRequset.newhostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newhostname(), target);
  }

  // required string newport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newport().data(), static_cast<int>(this->_internal_newport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.HelpJoinRequset.newport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_newport(), target);
  }

  // required int64 newhostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_newhostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.HelpJoinRequset)
  return target;
}

size_t HelpJoinRequset::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.HelpJoinRequset)
  size_t total_size = 0;

  if (_internal_has_newhostname()) {
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());
  }

  if (_internal_has_newport()) {
    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());
  }

  if (_internal_has_newhostnamehash()) {
    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());
  }

  return total_size;
}
size_t HelpJoinRequset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.HelpJoinRequset)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string newhostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newhostname());

    // required string newport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newport());

    // required int64 newhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_newhostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HelpJoinRequset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HelpJoinRequset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HelpJoinRequset::GetClassData() const { return &_class_data_; }

void HelpJoinRequset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HelpJoinRequset *>(to)->MergeFrom(
      static_cast<const HelpJoinRequset &>(from));
}


void HelpJoinRequset::MergeFrom(const HelpJoinRequset& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.HelpJoinRequset)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_newhostname(from._internal_newhostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_newport(from._internal_newport());
    }
    if (cached_has_bits & 0x00000004u) {
      newhostnamehash_ = from.newhostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HelpJoinRequset::CopyFrom(const HelpJoinRequset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.HelpJoinRequset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HelpJoinRequset::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void HelpJoinRequset::InternalSwap(HelpJoinRequset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newhostname_, lhs_arena,
      &other->newhostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newport_, lhs_arena,
      &other->newport_, rhs_arena
  );
  swap(newhostnamehash_, other->newhostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HelpJoinRequset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[14]);
}

// ===================================================================

class HelpJoinResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HelpJoinResponse>()._has_bits_);
  static void set_has_responsiblehostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_responsibleport(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_responhostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

HelpJoinResponse::HelpJoinResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.HelpJoinResponse)
}
HelpJoinResponse::HelpJoinResponse(const HelpJoinResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  responsiblehostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    responsiblehostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_responsiblehostname()) {
    responsiblehostname_.Set(from._internal_responsiblehostname(), 
      GetArenaForAllocation());
  }
  responsibleport_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    responsibleport_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_responsibleport()) {
    responsibleport_.Set(from._internal_responsibleport(), 
      GetArenaForAllocation());
  }
  responhostnamehash_ = from.responhostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.HelpJoinResponse)
}

inline void HelpJoinResponse::SharedCtor() {
responsiblehostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  responsiblehostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
responsibleport_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  responsibleport_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
responhostnamehash_ = int64_t{0};
}

HelpJoinResponse::~HelpJoinResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.HelpJoinResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HelpJoinResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  responsiblehostname_.Destroy();
  responsibleport_.Destroy();
}

void HelpJoinResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HelpJoinResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.HelpJoinResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      responsiblehostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      responsibleport_.ClearNonDefaultToEmpty();
    }
  }
  responhostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HelpJoinResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string responsiblehostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_responsiblehostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.HelpJoinResponse.responsiblehostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string responsibleport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_responsibleport();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.HelpJoinResponse.responsibleport");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 responhostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_responhostnamehash(&has_bits);
          responhostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HelpJoinResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.HelpJoinResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string responsiblehostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_responsiblehostname().data(), static_cast<int>(this->_internal_responsiblehostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.HelpJoinResponse.responsiblehostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_responsiblehostname(), target);
  }

  // required string responsibleport = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_responsibleport().data(), static_cast<int>(this->_internal_responsibleport().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.HelpJoinResponse.responsibleport");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_responsibleport(), target);
  }

  // required int64 responhostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_responhostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.HelpJoinResponse)
  return target;
}

size_t HelpJoinResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.HelpJoinResponse)
  size_t total_size = 0;

  if (_internal_has_responsiblehostname()) {
    // required string responsiblehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_responsiblehostname());
  }

  if (_internal_has_responsibleport()) {
    // required string responsibleport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_responsibleport());
  }

  if (_internal_has_responhostnamehash()) {
    // required int64 responhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_responhostnamehash());
  }

  return total_size;
}
size_t HelpJoinResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.HelpJoinResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string responsiblehostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_responsiblehostname());

    // required string responsibleport = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_responsibleport());

    // required int64 responhostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_responhostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HelpJoinResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HelpJoinResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HelpJoinResponse::GetClassData() const { return &_class_data_; }

void HelpJoinResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HelpJoinResponse *>(to)->MergeFrom(
      static_cast<const HelpJoinResponse &>(from));
}


void HelpJoinResponse::MergeFrom(const HelpJoinResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.HelpJoinResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_responsiblehostname(from._internal_responsiblehostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_responsibleport(from._internal_responsibleport());
    }
    if (cached_has_bits & 0x00000004u) {
      responhostnamehash_ = from.responhostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HelpJoinResponse::CopyFrom(const HelpJoinResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.HelpJoinResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HelpJoinResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void HelpJoinResponse::InternalSwap(HelpJoinResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &responsiblehostname_, lhs_arena,
      &other->responsiblehostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &responsibleport_, lhs_arena,
      &other->responsibleport_, rhs_arena
  );
  swap(responhostnamehash_, other->responhostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HelpJoinResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[15]);
}

// ===================================================================

class LookupNodeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LookupNodeResponse>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hostnamehash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LookupNodeResponse::LookupNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.LookupNodeResponse)
}
LookupNodeResponse::LookupNodeResponse(const LookupNodeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(from._internal_hostname(), 
      GetArenaForAllocation());
  }
  port_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    port_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_port()) {
    port_.Set(from._internal_port(), 
      GetArenaForAllocation());
  }
  hostnamehash_ = from.hostnamehash_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.LookupNodeResponse)
}

inline void LookupNodeResponse::SharedCtor() {
hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  port_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hostnamehash_ = int64_t{0};
}

LookupNodeResponse::~LookupNodeResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.LookupNodeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LookupNodeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.Destroy();
  port_.Destroy();
}

void LookupNodeResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LookupNodeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.LookupNodeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      port_.ClearNonDefaultToEmpty();
    }
  }
  hostnamehash_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LookupNodeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupNodeResponse.hostname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_port();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "p2pfilesharing.LookupNodeResponse.port");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 hostnamehash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hostnamehash(&has_bits);
          hostnamehash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LookupNodeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.LookupNodeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupNodeResponse.hostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  // required string port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_port().data(), static_cast<int>(this->_internal_port().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "p2pfilesharing.LookupNodeResponse.port");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_port(), target);
  }

  // required int64 hostnamehash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_hostnamehash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.LookupNodeResponse)
  return target;
}

size_t LookupNodeResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:p2pfilesharing.LookupNodeResponse)
  size_t total_size = 0;

  if (_internal_has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  if (_internal_has_port()) {
    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());
  }

  if (_internal_has_hostnamehash()) {
    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());
  }

  return total_size;
}
size_t LookupNodeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.LookupNodeResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());

    // required string port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port());

    // required int64 hostnamehash = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hostnamehash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LookupNodeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LookupNodeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LookupNodeResponse::GetClassData() const { return &_class_data_; }

void LookupNodeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LookupNodeResponse *>(to)->MergeFrom(
      static_cast<const LookupNodeResponse &>(from));
}


void LookupNodeResponse::MergeFrom(const LookupNodeResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.LookupNodeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_port(from._internal_port());
    }
    if (cached_has_bits & 0x00000004u) {
      hostnamehash_ = from.hostnamehash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LookupNodeResponse::CopyFrom(const LookupNodeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.LookupNodeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LookupNodeResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LookupNodeResponse::InternalSwap(LookupNodeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &port_, lhs_arena,
      &other->port_, rhs_arena
  );
  swap(hostnamehash_, other->hostnamehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LookupNodeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[16]);
}

// ===================================================================

class NodeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeRequest>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::p2pfilesharing::AddFileRequest& addfile(const NodeRequest* msg);
  static void set_has_addfile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::p2pfilesharing::LookupFileRequest& lookup(const NodeRequest* msg);
  static void set_has_lookup(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::p2pfilesharing::DeleteFileRequest& deletefile(const NodeRequest* msg);
  static void set_has_deletefile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::p2pfilesharing::DownloadRequest& download(const NodeRequest* msg);
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::p2pfilesharing::JoinRequest& join(const NodeRequest* msg);
  static void set_has_join(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::p2pfilesharing::RouteUpdateRequest& updateroute(const NodeRequest* msg);
  static void set_has_updateroute(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::p2pfilesharing::RouteDeleteRequest& deleteroute(const NodeRequest* msg);
  static void set_has_deleteroute(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::p2pfilesharing::HelpJoinRequset& helpjoin(const NodeRequest* msg);
  static void set_has_helpjoin(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000100) ^ 0x00000100) != 0;
  }
};

const ::p2pfilesharing::AddFileRequest&
NodeRequest::_Internal::addfile(const NodeRequest* msg) {
  return *msg->addfile_;
}
const ::p2pfilesharing::LookupFileRequest&
NodeRequest::_Internal::lookup(const NodeRequest* msg) {
  return *msg->lookup_;
}
const ::p2pfilesharing::DeleteFileRequest&
NodeRequest::_Internal::deletefile(const NodeRequest* msg) {
  return *msg->deletefile_;
}
const ::p2pfilesharing::DownloadRequest&
NodeRequest::_Internal::download(const NodeRequest* msg) {
  return *msg->download_;
}
const ::p2pfilesharing::JoinRequest&
NodeRequest::_Internal::join(const NodeRequest* msg) {
  return *msg->join_;
}
const ::p2pfilesharing::RouteUpdateRequest&
NodeRequest::_Internal::updateroute(const NodeRequest* msg) {
  return *msg->updateroute_;
}
const ::p2pfilesharing::RouteDeleteRequest&
NodeRequest::_Internal::deleteroute(const NodeRequest* msg) {
  return *msg->deleteroute_;
}
const ::p2pfilesharing::HelpJoinRequset&
NodeRequest::_Internal::helpjoin(const NodeRequest* msg) {
  return *msg->helpjoin_;
}
NodeRequest::NodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.NodeRequest)
}
NodeRequest::NodeRequest(const NodeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_addfile()) {
    addfile_ = new ::p2pfilesharing::AddFileRequest(*from.addfile_);
  } else {
    addfile_ = nullptr;
  }
  if (from._internal_has_lookup()) {
    lookup_ = new ::p2pfilesharing::LookupFileRequest(*from.lookup_);
  } else {
    lookup_ = nullptr;
  }
  if (from._internal_has_deletefile()) {
    deletefile_ = new ::p2pfilesharing::DeleteFileRequest(*from.deletefile_);
  } else {
    deletefile_ = nullptr;
  }
  if (from._internal_has_download()) {
    download_ = new ::p2pfilesharing::DownloadRequest(*from.download_);
  } else {
    download_ = nullptr;
  }
  if (from._internal_has_join()) {
    join_ = new ::p2pfilesharing::JoinRequest(*from.join_);
  } else {
    join_ = nullptr;
  }
  if (from._internal_has_updateroute()) {
    updateroute_ = new ::p2pfilesharing::RouteUpdateRequest(*from.updateroute_);
  } else {
    updateroute_ = nullptr;
  }
  if (from._internal_has_deleteroute()) {
    deleteroute_ = new ::p2pfilesharing::RouteDeleteRequest(*from.deleteroute_);
  } else {
    deleteroute_ = nullptr;
  }
  if (from._internal_has_helpjoin()) {
    helpjoin_ = new ::p2pfilesharing::HelpJoinRequset(*from.helpjoin_);
  } else {
    helpjoin_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.NodeRequest)
}

inline void NodeRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&addfile_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&addfile_)) + sizeof(type_));
}

NodeRequest::~NodeRequest() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.NodeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete addfile_;
  if (this != internal_default_instance()) delete lookup_;
  if (this != internal_default_instance()) delete deletefile_;
  if (this != internal_default_instance()) delete download_;
  if (this != internal_default_instance()) delete join_;
  if (this != internal_default_instance()) delete updateroute_;
  if (this != internal_default_instance()) delete deleteroute_;
  if (this != internal_default_instance()) delete helpjoin_;
}

void NodeRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.NodeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(addfile_ != nullptr);
      addfile_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lookup_ != nullptr);
      lookup_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(deletefile_ != nullptr);
      deletefile_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(download_ != nullptr);
      download_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(join_ != nullptr);
      join_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(updateroute_ != nullptr);
      updateroute_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(deleteroute_ != nullptr);
      deleteroute_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(helpjoin_ != nullptr);
      helpjoin_->Clear();
    }
  }
  type_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.AddFileRequest addfile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_addfile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.LookupFileRequest lookup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.DeleteFileRequest deletefile = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_deletefile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.DownloadRequest download = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.JoinRequest join = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_join(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteUpdateRequest updateroute = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateroute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_deleteroute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.HelpJoinRequset helpjoin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_helpjoin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.NodeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 type = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_type(), target);
  }

  // optional .p2pfilesharing.AddFileRequest addfile = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::addfile(this),
        _Internal::addfile(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.LookupFileRequest lookup = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::lookup(this),
        _Internal::lookup(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.DeleteFileRequest deletefile = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::deletefile(this),
        _Internal::deletefile(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.DownloadRequest download = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::download(this),
        _Internal::download(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.JoinRequest join = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::join(this),
        _Internal::join(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteUpdateRequest updateroute = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::updateroute(this),
        _Internal::updateroute(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::deleteroute(this),
        _Internal::deleteroute(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.HelpJoinRequset helpjoin = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::helpjoin(this),
        _Internal::helpjoin(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.NodeRequest)
  return target;
}

size_t NodeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.NodeRequest)
  size_t total_size = 0;

  // required int64 type = 1;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .p2pfilesharing.AddFileRequest addfile = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *addfile_);
    }

    // optional .p2pfilesharing.LookupFileRequest lookup = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookup_);
    }

    // optional .p2pfilesharing.DeleteFileRequest deletefile = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *deletefile_);
    }

    // optional .p2pfilesharing.DownloadRequest download = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *download_);
    }

    // optional .p2pfilesharing.JoinRequest join = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *join_);
    }

    // optional .p2pfilesharing.RouteUpdateRequest updateroute = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *updateroute_);
    }

    // optional .p2pfilesharing.RouteDeleteRequest deleteroute = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *deleteroute_);
    }

    // optional .p2pfilesharing.HelpJoinRequset helpjoin = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *helpjoin_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NodeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeRequest::GetClassData() const { return &_class_data_; }

void NodeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NodeRequest *>(to)->MergeFrom(
      static_cast<const NodeRequest &>(from));
}


void NodeRequest::MergeFrom(const NodeRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.NodeRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_addfile()->::p2pfilesharing::AddFileRequest::MergeFrom(from._internal_addfile());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_lookup()->::p2pfilesharing::LookupFileRequest::MergeFrom(from._internal_lookup());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_deletefile()->::p2pfilesharing::DeleteFileRequest::MergeFrom(from._internal_deletefile());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_download()->::p2pfilesharing::DownloadRequest::MergeFrom(from._internal_download());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_join()->::p2pfilesharing::JoinRequest::MergeFrom(from._internal_join());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_updateroute()->::p2pfilesharing::RouteUpdateRequest::MergeFrom(from._internal_updateroute());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_deleteroute()->::p2pfilesharing::RouteDeleteRequest::MergeFrom(from._internal_deleteroute());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_helpjoin()->::p2pfilesharing::HelpJoinRequset::MergeFrom(from._internal_helpjoin());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeRequest::CopyFrom(const NodeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.NodeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_addfile()) {
    if (!addfile_->IsInitialized()) return false;
  }
  if (_internal_has_lookup()) {
    if (!lookup_->IsInitialized()) return false;
  }
  if (_internal_has_deletefile()) {
    if (!deletefile_->IsInitialized()) return false;
  }
  if (_internal_has_download()) {
    if (!download_->IsInitialized()) return false;
  }
  if (_internal_has_join()) {
    if (!join_->IsInitialized()) return false;
  }
  if (_internal_has_updateroute()) {
    if (!updateroute_->IsInitialized()) return false;
  }
  if (_internal_has_deleteroute()) {
    if (!deleteroute_->IsInitialized()) return false;
  }
  if (_internal_has_helpjoin()) {
    if (!helpjoin_->IsInitialized()) return false;
  }
  return true;
}

void NodeRequest::InternalSwap(NodeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeRequest, type_)
      + sizeof(NodeRequest::type_)
      - PROTOBUF_FIELD_OFFSET(NodeRequest, addfile_)>(
          reinterpret_cast<char*>(&addfile_),
          reinterpret_cast<char*>(&other->addfile_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[17]);
}

// ===================================================================

class NodeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NodeResponse>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::p2pfilesharing::LookupFileResponse& lookup(const NodeResponse* msg);
  static void set_has_lookup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::p2pfilesharing::FileInfoResponse& fileinforsp(const NodeResponse* msg);
  static void set_has_fileinforsp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::p2pfilesharing::RouteTableInit& routeinit(const NodeResponse* msg);
  static void set_has_routeinit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::p2pfilesharing::FileTable& filetable(const NodeResponse* msg);
  static void set_has_filetable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::p2pfilesharing::HelpJoinResponse& helpjoin(const NodeResponse* msg);
  static void set_has_helpjoin(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::p2pfilesharing::RouteUpdateResponse& updateroute(const NodeResponse* msg);
  static void set_has_updateroute(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::p2pfilesharing::LookupNodeResponse& lookupnode(const NodeResponse* msg);
  static void set_has_lookupnode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000080) ^ 0x00000080) != 0;
  }
};

const ::p2pfilesharing::LookupFileResponse&
NodeResponse::_Internal::lookup(const NodeResponse* msg) {
  return *msg->lookup_;
}
const ::p2pfilesharing::FileInfoResponse&
NodeResponse::_Internal::fileinforsp(const NodeResponse* msg) {
  return *msg->fileinforsp_;
}
const ::p2pfilesharing::RouteTableInit&
NodeResponse::_Internal::routeinit(const NodeResponse* msg) {
  return *msg->routeinit_;
}
const ::p2pfilesharing::FileTable&
NodeResponse::_Internal::filetable(const NodeResponse* msg) {
  return *msg->filetable_;
}
const ::p2pfilesharing::HelpJoinResponse&
NodeResponse::_Internal::helpjoin(const NodeResponse* msg) {
  return *msg->helpjoin_;
}
const ::p2pfilesharing::RouteUpdateResponse&
NodeResponse::_Internal::updateroute(const NodeResponse* msg) {
  return *msg->updateroute_;
}
const ::p2pfilesharing::LookupNodeResponse&
NodeResponse::_Internal::lookupnode(const NodeResponse* msg) {
  return *msg->lookupnode_;
}
NodeResponse::NodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:p2pfilesharing.NodeResponse)
}
NodeResponse::NodeResponse(const NodeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lookup()) {
    lookup_ = new ::p2pfilesharing::LookupFileResponse(*from.lookup_);
  } else {
    lookup_ = nullptr;
  }
  if (from._internal_has_fileinforsp()) {
    fileinforsp_ = new ::p2pfilesharing::FileInfoResponse(*from.fileinforsp_);
  } else {
    fileinforsp_ = nullptr;
  }
  if (from._internal_has_routeinit()) {
    routeinit_ = new ::p2pfilesharing::RouteTableInit(*from.routeinit_);
  } else {
    routeinit_ = nullptr;
  }
  if (from._internal_has_filetable()) {
    filetable_ = new ::p2pfilesharing::FileTable(*from.filetable_);
  } else {
    filetable_ = nullptr;
  }
  if (from._internal_has_helpjoin()) {
    helpjoin_ = new ::p2pfilesharing::HelpJoinResponse(*from.helpjoin_);
  } else {
    helpjoin_ = nullptr;
  }
  if (from._internal_has_updateroute()) {
    updateroute_ = new ::p2pfilesharing::RouteUpdateResponse(*from.updateroute_);
  } else {
    updateroute_ = nullptr;
  }
  if (from._internal_has_lookupnode()) {
    lookupnode_ = new ::p2pfilesharing::LookupNodeResponse(*from.lookupnode_);
  } else {
    lookupnode_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:p2pfilesharing.NodeResponse)
}

inline void NodeResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lookup_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&lookup_)) + sizeof(type_));
}

NodeResponse::~NodeResponse() {
  // @@protoc_insertion_point(destructor:p2pfilesharing.NodeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete lookup_;
  if (this != internal_default_instance()) delete fileinforsp_;
  if (this != internal_default_instance()) delete routeinit_;
  if (this != internal_default_instance()) delete filetable_;
  if (this != internal_default_instance()) delete helpjoin_;
  if (this != internal_default_instance()) delete updateroute_;
  if (this != internal_default_instance()) delete lookupnode_;
}

void NodeResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:p2pfilesharing.NodeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(lookup_ != nullptr);
      lookup_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fileinforsp_ != nullptr);
      fileinforsp_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(routeinit_ != nullptr);
      routeinit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(filetable_ != nullptr);
      filetable_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(helpjoin_ != nullptr);
      helpjoin_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(updateroute_ != nullptr);
      updateroute_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(lookupnode_ != nullptr);
      lookupnode_->Clear();
    }
  }
  type_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.LookupFileResponse lookup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinforsp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteTableInit routeinit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_routeinit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.FileTable filetable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_filetable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.HelpJoinResponse helpjoin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_helpjoin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.RouteUpdateResponse updateroute = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_updateroute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .p2pfilesharing.LookupNodeResponse lookupnode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookupnode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:p2pfilesharing.NodeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_type(), target);
  }

  // optional .p2pfilesharing.LookupFileResponse lookup = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::lookup(this),
        _Internal::lookup(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fileinforsp(this),
        _Internal::fileinforsp(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteTableInit routeinit = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::routeinit(this),
        _Internal::routeinit(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.FileTable filetable = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::filetable(this),
        _Internal::filetable(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.HelpJoinResponse helpjoin = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::helpjoin(this),
        _Internal::helpjoin(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.RouteUpdateResponse updateroute = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::updateroute(this),
        _Internal::updateroute(this).GetCachedSize(), target, stream);
  }

  // optional .p2pfilesharing.LookupNodeResponse lookupnode = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::lookupnode(this),
        _Internal::lookupnode(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:p2pfilesharing.NodeResponse)
  return target;
}

size_t NodeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:p2pfilesharing.NodeResponse)
  size_t total_size = 0;

  // required int64 type = 1;
  if (_internal_has_type()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .p2pfilesharing.LookupFileResponse lookup = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookup_);
    }

    // optional .p2pfilesharing.FileInfoResponse fileinforsp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fileinforsp_);
    }

    // optional .p2pfilesharing.RouteTableInit routeinit = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *routeinit_);
    }

    // optional .p2pfilesharing.FileTable filetable = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filetable_);
    }

    // optional .p2pfilesharing.HelpJoinResponse helpjoin = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *helpjoin_);
    }

    // optional .p2pfilesharing.RouteUpdateResponse updateroute = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *updateroute_);
    }

    // optional .p2pfilesharing.LookupNodeResponse lookupnode = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lookupnode_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    NodeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodeResponse::GetClassData() const { return &_class_data_; }

void NodeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<NodeResponse *>(to)->MergeFrom(
      static_cast<const NodeResponse &>(from));
}


void NodeResponse::MergeFrom(const NodeResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:p2pfilesharing.NodeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_lookup()->::p2pfilesharing::LookupFileResponse::MergeFrom(from._internal_lookup());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fileinforsp()->::p2pfilesharing::FileInfoResponse::MergeFrom(from._internal_fileinforsp());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_routeinit()->::p2pfilesharing::RouteTableInit::MergeFrom(from._internal_routeinit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_filetable()->::p2pfilesharing::FileTable::MergeFrom(from._internal_filetable());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_helpjoin()->::p2pfilesharing::HelpJoinResponse::MergeFrom(from._internal_helpjoin());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_updateroute()->::p2pfilesharing::RouteUpdateResponse::MergeFrom(from._internal_updateroute());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_lookupnode()->::p2pfilesharing::LookupNodeResponse::MergeFrom(from._internal_lookupnode());
    }
    if (cached_has_bits & 0x00000080u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodeResponse::CopyFrom(const NodeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:p2pfilesharing.NodeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_lookup()) {
    if (!lookup_->IsInitialized()) return false;
  }
  if (_internal_has_fileinforsp()) {
    if (!fileinforsp_->IsInitialized()) return false;
  }
  if (_internal_has_routeinit()) {
    if (!routeinit_->IsInitialized()) return false;
  }
  if (_internal_has_filetable()) {
    if (!filetable_->IsInitialized()) return false;
  }
  if (_internal_has_helpjoin()) {
    if (!helpjoin_->IsInitialized()) return false;
  }
  if (_internal_has_updateroute()) {
    if (!updateroute_->IsInitialized()) return false;
  }
  if (_internal_has_lookupnode()) {
    if (!lookupnode_->IsInitialized()) return false;
  }
  return true;
}

void NodeResponse::InternalSwap(NodeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeResponse, type_)
      + sizeof(NodeResponse::type_)
      - PROTOBUF_FIELD_OFFSET(NodeResponse, lookup_)>(
          reinterpret_cast<char*>(&lookup_),
          reinterpret_cast<char*>(&other->lookup_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NodeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_P2P_5fProtocol_2eproto_getter, &descriptor_table_P2P_5fProtocol_2eproto_once,
      file_level_metadata_P2P_5fProtocol_2eproto[18]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace p2pfilesharing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::p2pfilesharing::AddFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::AddFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::AddFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::DeleteFileRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::DeleteFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::DeleteFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupFileResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileInfoResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileInfoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileInfoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::DownloadRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::DownloadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::DownloadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::JoinRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::JoinRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::JoinRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteTableInit*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteTableInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteTableInit >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileTable*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileTable >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::FileTableEntry*
Arena::CreateMaybeMessage< ::p2pfilesharing::FileTableEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::FileTableEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteUpdateRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteUpdateResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::RouteDeleteRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::RouteDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::RouteDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::HelpJoinRequset*
Arena::CreateMaybeMessage< ::p2pfilesharing::HelpJoinRequset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::HelpJoinRequset >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::HelpJoinResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::HelpJoinResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::HelpJoinResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::LookupNodeResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::LookupNodeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::LookupNodeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::NodeRequest*
Arena::CreateMaybeMessage< ::p2pfilesharing::NodeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::NodeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::p2pfilesharing::NodeResponse*
Arena::CreateMaybeMessage< ::p2pfilesharing::NodeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::p2pfilesharing::NodeResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
